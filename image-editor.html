<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç”»åƒã‚¨ãƒ‡ã‚£ã‚¿ - ãƒ†ã‚­ã‚¹ãƒˆï¼†å¹ãå‡ºã—è¿½åŠ </title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .toolbar-group {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 12px 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .toolbar-group label {
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
            white-space: nowrap;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            white-space: nowrap;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
        }

        button.secondary:hover {
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.6);
        }

        input[type="file"] {
            padding: 8px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: white;
            cursor: pointer;
        }

        input[type="text"],
        input[type="number"],
        select,
        textarea {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 0.95em;
            transition: border-color 0.3s ease;
            width: 100%;
            font-family: inherit;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            padding: 2px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .canvas-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            align-items: flex-start;
        }

        .canvas-wrapper {
            flex: 1;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
            overflow: auto;
            max-height: 80vh;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 500px;
        }

        #canvas {
            border: 2px solid #667eea;
            cursor: crosshair;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .properties-panel {
            width: 350px;
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
            max-height: 80vh;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .properties-panel h3 {
            color: #667eea;
            margin: 20px 0 15px 0;
            font-size: 1.2em;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 5px;
        }

        .properties-panel h3:first-child {
            margin-top: 0;
        }

        .property-group {
            margin-bottom: 15px;
        }

        .property-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        .horizontal-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .horizontal-group>* {
            flex: 1;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 5px;
            background: #f8f9fa;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #eee;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .checkbox-group:hover {
            background: #eef2f7;
            border-color: #cbd5e0;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-group label {
            margin-bottom: 0;
            cursor: pointer;
        }

        .control-btn {
            width: 100%;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .layer-list {
            max-height: 150px;
            overflow-y: auto;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 10px;
            border: 1px solid #eee;
        }

        .layer-item {
            padding: 8px 12px;
            margin-bottom: 5px;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
            border: 1px solid #eee;
            font-size: 0.9em;
        }

        .layer-item:hover {
            border-color: #667eea;
            transform: translateX(2px);
        }

        .layer-item.selected {
            background: #ebf4ff;
            border-color: #667eea;
            color: #2b6cb0;
            font-weight: 600;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.9em;
            color: #1976d2;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .container {
            animation: fadeIn 0.5s ease;
        }

        /* ã‚«ã‚¹ã‚¿ãƒ ã‚¢ã‚»ãƒƒãƒˆç®¡ç†ç”¨CSS */
        .custom-assets-area {
            margin-top: 10px;
            border-top: 1px dashed #ddd;
            padding-top: 10px;
            background: #fdfdfd;
            padding: 10px;
            border-radius: 8px;
        }

        .custom-file-input {
            display: none;
        }

        .custom-btn {
            font-size: 0.8em;
            padding: 5px 10px;
            background: #eee;
            color: #333;
            box-shadow: none;
            border: 1px solid #ddd;
        }

        .custom-btn:hover {
            background: #e0e0e0;
            transform: none;
            box-shadow: none;
        }

        .custom-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .custom-item {
            width: 50px;
            height: 50px;
            border: 2px solid #eee;
            border-radius: 5px;
            cursor: pointer;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            background-color: #fff;
            position: relative;
            transition: all 0.2s;
        }

        .custom-item:hover {
            border-color: #667eea;
        }

        .delete-btn {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 16px;
            height: 16px;
            background: #ff5252;
            color: white;
            border-radius: 50%;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            display: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        .custom-item:hover .delete-btn {
            display: flex;
            opacity: 1;
        }

        .preview-popup {
            position: fixed;
            border: 2px solid #667eea;
            background: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            pointer-events: none;
            display: none;
            border-radius: 10px;
            padding: 5px;
            width: 300px;
            /* å›ºå®šã‚µã‚¤ã‚º */
            height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .preview-popup img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .font-delete-btn {
            color: #ff5252;
            cursor: pointer;
            margin-left: 5px;
            font-size: 0.8em;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ¨ ç”»åƒã‚¨ãƒ‡ã‚£ã‚¿</h1>



        <div class="toolbar">
            <!-- ç”»åƒèª­ã¿è¾¼ã¿ -->
            <div class="toolbar-group">
                <label>ğŸ“ ç”»åƒèª­è¾¼:</label>
                <input type="file" id="imageInput" accept="image/*">
            </div>

            <!-- ç·¨é›†ãƒ»ä¿å­˜ -->
            <div class="toolbar-group">
                <button class="secondary" onclick="deleteSelected()">ğŸ—‘ï¸ å‰Šé™¤</button>
                <button onclick="saveProject()">ğŸ’¾ ä¿å­˜</button>
                <button onclick="loadProject()">ğŸ“‚ èª­è¾¼</button>
                <button onclick="exportImage()">ğŸ“¥ å‡ºåŠ›</button>
            </div>
        </div>

        <div class="canvas-container">
            <div class="canvas-wrapper">
                <canvas id="canvas"></canvas>
            </div>

            <div class="properties-panel">
                <h3>ãƒ†ã‚­ã‚¹ãƒˆè¨­å®š</h3>

                <!-- 1. ãƒ†ã‚­ã‚¹ãƒˆæ¬„ -->
                <div class="property-group">
                    <textarea id="textContent" placeholder="ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆæ”¹è¡Œå¯ï¼‰" rows="3"></textarea>
                </div>

                <!-- 2. å¤ªå­—ãƒ»ç¸å–ã‚Šãƒ»æ¨ªæ›¸ã (æ¨ªä¸¦ã³) -->
                <div class="property-group horizontal-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="boldText">
                        <label for="boldText">å¤ªå­—</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="strokeText">
                        <label for="strokeText">ç¸å–ã‚Š</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="horizontalText">
                        <label for="horizontalText">æ¨ªæ›¸ã</label>
                    </div>
                </div>

                <!-- ç¸å–ã‚Šã‚ªãƒ—ã‚·ãƒ§ãƒ³ -->
                <div class="property-group horizontal-group" id="strokeOptions" style="display:none;">
                    <div>
                        <label style="font-size:0.8em;">ç¸è‰²</label>
                        <input type="color" id="strokeColor" value="#ffffff" style="height:30px;">
                    </div>
                    <div style="flex:2;">
                        <label style="font-size:0.8em;">ç¸å¹…</label>
                        <input type="number" id="strokeWidth" value="3" min="1" max="20" style="padding:4px;">
                    </div>
                </div>

                <!-- 3. ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã¨ãƒ†ã‚­ã‚¹ãƒˆè‰² (æ¨ªä¸¦ã³) - ç§»å‹• -->
                <div class="property-group horizontal-group">
                    <div style="flex: 1;">
                        <label>ã‚µã‚¤ã‚º</label>
                        <input type="number" id="fontSize" value="32" min="10" max="200">
                    </div>
                    <div style="flex: 1;">
                        <label>è‰²</label>
                        <input type="color" id="textColor" value="#000000">
                    </div>
                </div>

                <!-- 4. ãƒ•ã‚©ãƒ³ãƒˆ - ç§»å‹• -->
                <div class="property-group">
                    <label>ãƒ•ã‚©ãƒ³ãƒˆ</label>
                    <select id="fontFamily">
                        <option value="'Yu Gothic', 'Meiryo', sans-serif">ã‚´ã‚·ãƒƒã‚¯ä½“</option>
                        <option value="'Yu Mincho', 'MS Mincho', serif">æ˜æœä½“</option>
                    </select>
                    <div class="custom-assets-area">
                        <label style="font-size: 0.8em; color: #666;">ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚©ãƒ³ãƒˆç®¡ç†</label>
                        <button class="custom-btn" onclick="document.getElementById('fontInput').click()">â•
                            ãƒ•ã‚©ãƒ³ãƒˆè¿½åŠ </button>
                        <input type="file" id="fontInput" class="custom-file-input" accept=".ttf,.woff,.woff2,font/*">
                        <div id="customFontList"
                            style="margin-top: 10px; display: flex; flex-direction: column; gap: 5px;"></div>
                        <!-- éè¡¨ç¤ºã« -->
                    </div>
                </div>

                <!-- 5. ãƒ†ã‚­ã‚¹ãƒˆè¿½åŠ  -->
                <div class="property-group">
                    <button class="control-btn" onclick="addText()">ğŸ“ ãƒ†ã‚­ã‚¹ãƒˆè¿½åŠ </button>
                </div>

                <h3>å¹ãå‡ºã—è¨­å®š</h3>

                <!-- 6. å››è§’å¹ãå‡ºã—ã€ä¸¸å¹ãå‡ºã— (æ¨ªä¸¦ã³) -->
                <div class="property-group horizontal-group">
                    <button class="control-btn" onclick="addBubble('rect')">ğŸ’­ å››è§’</button>
                    <button class="control-btn" onclick="addBubble('round')">ğŸ’¬ ä¸¸</button>
                    <button class="control-btn" onclick="addBubble('flash')">ğŸ’¥ ãƒ•ãƒ©ãƒƒã‚·ãƒ¥</button>
                </div>

                <!-- 8. å¹ãå‡ºã—é€æ˜åº¦ãƒãƒ¼ -->
                <div class="property-group">
                    <label>é€æ˜åº¦: <span id="opacityValue">100</span>%</label>
                    <input type="range" id="bubbleOpacity" min="0" max="100" value="100">
                </div>

                <!-- 9. å›è»¢ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ -->
                <div class="property-group">
                    <label>å›è»¢: <span id="rotationValue">0</span>Â°</label>
                    <input type="range" id="elementRotation" min="-180" max="180" value="0">
                </div>

                <!-- ç§»å‹•: ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œãƒœã‚¿ãƒ³ -->
                <div class="property-group">
                    <div class="horizontal-group" style="margin-bottom: 10px;">
                        <button onclick="moveToFront()">â¬†ï¸ å‰é¢</button>
                        <button onclick="moveToBack()">â¬‡ï¸ èƒŒé¢</button>
                    </div>
                </div>

                <div class="custom-assets-area">
                    <label style="font-size: 0.8em; color: #666;">ã‚«ã‚¹ã‚¿ãƒ å¹ãå‡ºã—</label>
                    <button class="custom-btn" onclick="document.getElementById('bubbleInput').click()">â• ç”»åƒè¿½åŠ </button>
                    <input type="file" id="bubbleInput" class="custom-file-input" accept="image/*" multiple>
                    <div id="customBubbleList" class="custom-list"></div>
                </div>

                <!-- 7. å¹ãå‡ºã—è‰²ãƒ»å¹ãå‡ºã—æ è‰² (æ¨ªä¸¦ã³) -->
                <div class="property-group horizontal-group">
                    <div style="flex: 1;">
                        <label>èƒŒæ™¯è‰²</label>
                        <input type="color" id="bubbleColor" value="#ffffff">
                    </div>
                    <div style="flex: 1;">
                        <label>æ è‰²</label>
                        <input type="color" id="bubbleBorderColor" value="#000000">
                    </div>
                </div>



                <h3>ãƒ¬ã‚¤ãƒ¤ãƒ¼ä¸€è¦§</h3>
                <div class="property-group">
                    <div class="layer-list" id="layerList"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="previewPopup" class="preview-popup">
        <img id="previewImage" src="">
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // ç¸å–ã‚Šã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆç”¨
        const strokeTextCheckbox = document.getElementById('strokeText');
        const strokeOptions = document.getElementById('strokeOptions');
        strokeTextCheckbox.addEventListener('change', function () {
            strokeOptions.style.display = this.checked ? 'flex' : 'none';
        });

        let originalImage = null;
        let displayScale = 0.5;
        let elements = [];
        let selectedElement = null;
        let selectedElements = []; // è¤‡æ•°é¸æŠç”¨

        // ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼ˆå¹ãå‡ºã—åˆæˆç”¨ï¼‰
        const bubbleOffscreen = document.createElement('canvas');
        const bubbleCtx = bubbleOffscreen.getContext('2d');

        let isDragging = false;
        let isResizing = false;
        let isRotating = false; // å›è»¢ä¸­ãƒ•ãƒ©ã‚°
        let dragStartX = 0;
        let dragStartY = 0;
        let initialRotation = 0; // å›è»¢é–‹å§‹æ™‚ã®è§’åº¦
        let initialRotationOffset = 0; // ãƒã‚¦ã‚¹è§’åº¦ã¨ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
        let resizeHandle = null;

        let clipboard = null; // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ç”¨

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆ (Delete, Copy, Paste)
        document.addEventListener('keydown', function (e) {
            // Delete
            if (e.key === 'Delete' && selectedElement) {
                deleteSelected();
                return;
            }

            // Copy (Ctrl+C)
            if ((e.ctrlKey || e.metaKey) && e.key === 'c' && selectedElement) {
                // imageObjç­‰ã®å¾ªç’°å‚ç…§ã‚’é¿ã‘ã‚‹ãŸã‚ã€å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ã®ã¿ã‚³ãƒ”ãƒ¼
                const clone = JSON.parse(JSON.stringify(selectedElement));
                // ã‚«ã‚¹ã‚¿ãƒ ç”»åƒã®å ´åˆã¯sourceãŒå¿…è¦
                if (selectedElement.source) {
                    clone.source = selectedElement.source;
                }
                clipboard = clone;
                return;
            }

            // Paste (Ctrl+V)
            if ((e.ctrlKey || e.metaKey) && e.key === 'v' && clipboard) {
                const newElement = JSON.parse(JSON.stringify(clipboard));

                // ä½ç½®ã‚’å°‘ã—ãšã‚‰ã™
                newElement.x += 20;
                newElement.y += 20;

                // ã‚«ã‚¹ã‚¿ãƒ ç”»åƒã®å¾©å…ƒå‡¦ç†
                if (newElement.type === 'bubble' && newElement.shape === 'custom' && newElement.source) {
                    const img = new Image();
                    img.onload = function () {
                        newElement.imageObj = img;
                        elements.push(newElement);
                        selectedElement = newElement;
                        selectedElements = [newElement];
                        updateProperties();
                        render();
                    };
                    img.src = newElement.source;
                } else {
                    elements.push(newElement);
                    selectedElement = newElement;
                    selectedElements = [newElement];
                    updateProperties();
                    render();
                }
            }
        });

        // ç”»åƒèª­ã¿è¾¼ã¿
        document.getElementById('imageInput').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (event) {
                    const img = new Image();
                    img.onload = function () {
                        originalImage = img;
                        canvas.width = img.width * displayScale;
                        canvas.height = img.height * displayScale;
                        // æ–°ã—ã„ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã ã‚‰è¦ç´ ã‚’ãƒªã‚»ãƒƒãƒˆ
                        elements = [];
                        selectedElement = null;
                        selectedElements = [];
                        render();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // ãƒ†ã‚­ã‚¹ãƒˆè¿½åŠ 
        function addText() {
            if (!originalImage) {
                alert('å…ˆã«ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„');
                return;
            }

            // ç¾åœ¨ã®è¨­å®šå€¤ã‚’DOMã‹ã‚‰å–å¾—
            const currentFontSize = parseInt(document.getElementById('fontSize').value) || 32;
            const currentFontFamily = document.getElementById('fontFamily').value;
            const currentColor = document.getElementById('textColor').value;
            const isBold = document.getElementById('boldText').checked;
            const isStroke = document.getElementById('strokeText').checked;
            const isHorizontal = document.getElementById('horizontalText').checked;
            const currentStrokeColor = document.getElementById('strokeColor').value;
            const currentStrokeWidth = parseInt(document.getElementById('strokeWidth').value) || 3;

            const element = {
                type: 'text',
                content: document.getElementById('textContent').value || 'ãƒ†ã‚­ã‚¹ãƒˆ',
                x: canvas.width / 2 / displayScale,
                y: canvas.height / 2 / displayScale,
                fontSize: currentFontSize,
                fontFamily: currentFontFamily,
                color: currentColor,
                bold: isBold,
                stroke: isStroke,
                strokeColor: currentStrokeColor,
                strokeWidth: currentStrokeWidth,
                vertical: !isHorizontal // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æ¨ªæ›¸ããƒã‚§ãƒƒã‚¯ãŒãªã‘ã‚Œã°ç¸¦æ›¸ã
            };

            elements.push(element);
            selectedElement = element;
            selectedElements = [element];
            updateProperties();
            render();
        }

        // å¹ãå‡ºã—è¿½åŠ ï¼ˆé›²ã¯å‰Šé™¤ï¼‰
        function addBubble(shape) {
            if (!originalImage) {
                alert('å…ˆã«ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„');
                return;
            }

            // ç¾åœ¨ã®è¨­å®šå€¤ã‚’DOMã‹ã‚‰å–å¾—
            const currentColor = document.getElementById('bubbleColor').value;
            const currentBorderColor = document.getElementById('bubbleBorderColor').value;
            const currentOpacity = parseInt(document.getElementById('bubbleOpacity').value) / 100;

            const element = {
                type: 'bubble',
                shape: shape,
                x: canvas.width / 2 / displayScale,
                y: canvas.height / 2 / displayScale,
                width: 200,
                height: 150,
                color: currentColor,
                borderColor: currentBorderColor,
                opacity: currentOpacity
            };

            elements.push(element);
            selectedElement = element;
            selectedElements = [element];
            updateProperties();
            render();
        }

        // æç”»
        function render() {
            if (!originalImage) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. ç”»åƒæç”»
            ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);

            // 2. å¹ãå‡ºã—ãƒ¬ã‚¤ãƒ¤ãƒ¼æç”» (åˆæˆ + ã‚«ã‚¹ã‚¿ãƒ )
            const allBubbles = elements.filter(el => el.type === 'bubble');
            const MERGEABLE_SHAPES = ['rect', 'round', 'flash'];
            const mergeBubbles = allBubbles.filter(el => MERGEABLE_SHAPES.includes(el.shape));
            const customBubbles = allBubbles.filter(el => !MERGEABLE_SHAPES.includes(el.shape));

            // 2-A. çµåˆå¯¾è±¡ãƒãƒ–ãƒ« (Rect/Round/Flash)
            if (mergeBubbles.length > 0) {
                // ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚µã‚¤ã‚ºèª¿æ•´
                if (bubbleOffscreen.width !== canvas.width || bubbleOffscreen.height !== canvas.height) {
                    bubbleOffscreen.width = canvas.width;
                    bubbleOffscreen.height = canvas.height;
                }
                bubbleCtx.clearRect(0, 0, bubbleOffscreen.width, bubbleOffscreen.height);

                // Pass 1: æ ç·š
                mergeBubbles.forEach(element => {
                    drawBubbleOnCtx(bubbleCtx, element, 'stroke', 1.0, displayScale);
                });

                // Pass 2: å¡—ã‚Š (æ ç·šæ¶ˆå» -> å¡—ã‚Š)
                mergeBubbles.forEach(element => {
                    bubbleCtx.save();
                    bubbleCtx.globalCompositeOperation = 'destination-out';
                    drawBubblePath(bubbleCtx, element, displayScale);
                    bubbleCtx.fillStyle = 'black';
                    bubbleCtx.globalAlpha = 1.0;
                    bubbleCtx.fill();
                    bubbleCtx.restore();

                    drawBubbleOnCtx(bubbleCtx, element, 'fill', 1.0, displayScale);
                });

                // æœ¬ä½“ã‚­ãƒ£ãƒ³ãƒã‚¹ã«åˆæˆ
                // é€éåº¦: é¸æŠä¸­ã®è¦ç´ ãŒã‚°ãƒ«ãƒ¼ãƒ—å†…ã«ã‚ã‚‹å ´åˆã¯ãã®å€¤ã‚’å„ªå…ˆã€ãªã‘ã‚Œã°æœ€å‰é¢ã®å€¤
                let groupOpacity = mergeBubbles[mergeBubbles.length - 1].opacity;
                if (groupOpacity === undefined) groupOpacity = 1.0;

                if (selectedElement && MERGEABLE_SHAPES.includes(selectedElement.shape)) {
                    // ç·¨é›†ä¸­ã¯ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åæ˜ ã®ãŸã‚é¸æŠè¦ç´ ã®å€¤ã‚’æ¡ç”¨
                    groupOpacity = selectedElement.opacity !== undefined ? selectedElement.opacity : 1.0;
                }

                ctx.save();
                ctx.globalAlpha = groupOpacity;
                ctx.drawImage(bubbleOffscreen, 0, 0);
                ctx.restore();
            }

            // 2-B. ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ–ãƒ« (å€‹åˆ¥æç”»)
            customBubbles.forEach(element => {
                const opacity = element.opacity !== undefined ? element.opacity : 1.0;
                drawBubbleOnCtx(ctx, element, 'image', opacity, displayScale);
            });

            // 3. ãƒ†ã‚­ã‚¹ãƒˆæç”» (å¹ãå‡ºã—ã®ä¸Šã«è¡¨ç¤º)
            elements.forEach(element => {
                if (element.type === 'text') {
                    drawText(element);
                }
            });

            // 4. é¸æŠãƒãƒ³ãƒ‰ãƒ«
            elements.forEach(element => {
                if (selectedElements.includes(element)) {
                    drawSelectionHandles(element);
                }
            });

            updateLayerList();
        }

        // å¹ãå‡ºã—æç”»ç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼ (ContextæŒ‡å®šç‰ˆ)
        function drawBubbleOnCtx(targetCtx, element, mode, opacity, scale) {
            targetCtx.save();
            const x = element.x * scale;
            const y = element.y * scale;
            const width = element.width * scale;
            const height = element.height * scale;

            // å›è»¢é©ç”¨
            targetCtx.translate(x, y);
            targetCtx.rotate((element.rotation || 0) * Math.PI / 180);
            targetCtx.translate(-x, -y);

            targetCtx.globalAlpha = opacity;
            targetCtx.fillStyle = element.color;
            targetCtx.strokeStyle = element.borderColor;
            targetCtx.lineWidth = 2 * scale;

            drawBubblePath(targetCtx, element, scale);

            if (element.shape === 'custom' && element.imageObj && mode !== 'stroke') {
                // ã‚«ã‚¹ã‚¿ãƒ ç”»åƒã¯ãƒ‘ã‚¹æç”»ã§ã¯ãªãdrawImage
                // destination-outå‡¦ç†ã®ãŸã‚ã«ã¯ãƒ‘ã‚¹ãŒå¿…è¦ã ãŒã€ç”»åƒã®å ´åˆã¯ã€ŒçŸ©å½¢ã€ã¨ã—ã¦å‡¦ç†ã™ã‚‹ã‹ï¼Ÿ
                // è¤‡é›‘ãªã®ã§ä¸€æ—¦ç”»åƒæç”»ã®ã¿
                try {
                    targetCtx.drawImage(element.imageObj, x - width / 2, y - height / 2, width, height);
                } catch (e) {
                    console.error(e);
                }
            } else {
                if (mode === 'fill') targetCtx.fill();
                if (mode === 'stroke') targetCtx.stroke();
            }
            targetCtx.restore();
        }

        function drawBubblePath(targetCtx, element, scale) {
            const x = element.x * scale;
            const y = element.y * scale;
            const width = element.width * scale;
            const height = element.height * scale;

            targetCtx.beginPath();
            if (element.shape === 'rect') {
                targetCtx.rect(x - width / 2, y - height / 2, width, height);
            } else if (element.shape === 'round') {
                targetCtx.ellipse(x, y, width / 2, height / 2, 0, 0, Math.PI * 2);
            } else if (element.shape === 'flash') {
                const spikes = 80;
                const outerRadiusX = width / 2;
                const outerRadiusY = height / 2;
                const innerRadiusX = width / 2 * 0.85;
                const innerRadiusY = height / 2 * 0.85;
                let rot = Math.PI / 2 * 3;
                let step = Math.PI / spikes;
                targetCtx.moveTo(x, y - outerRadiusY);
                for (let i = 0; i < spikes; i++) {
                    let cx = x + Math.cos(rot) * outerRadiusX;
                    let cy = y + Math.sin(rot) * outerRadiusY;
                    targetCtx.lineTo(cx, cy);
                    rot += step;
                    cx = x + Math.cos(rot) * innerRadiusX;
                    cy = y + Math.sin(rot) * innerRadiusY;
                    targetCtx.lineTo(cx, cy);
                    rot += step;
                }
                targetCtx.lineTo(x, y - outerRadiusY);
                targetCtx.closePath();
            } else if (element.shape === 'custom') {
                // ã‚«ã‚¹ã‚¿ãƒ ã®å ´åˆã¯çŸ©å½¢ãƒ‘ã‚¹ã‚’ä½œã£ã¦ãŠãï¼ˆæ¶ˆå»ç”¨ï¼‰
                targetCtx.rect(x - width / 2, y - height / 2, width, height);
            }
        }

        // ãƒ†ã‚­ã‚¹ãƒˆæç”»
        function getVerticalCharDetails(char, fontSize) {
            const details = { x: 0, y: 0, scale: 1.0, rotate: 0 };

            // 90åº¦å›è»¢ã•ã›ã‚‹æ–‡å­—ã®ãƒªã‚¹ãƒˆï¼ˆé•·éŸ³ã€ãƒ€ãƒƒã‚·ãƒ¥ã€æ‹¬å¼§ã€ä¸‰ç‚¹ãƒªãƒ¼ãƒ€ãƒ¼ãªã©ï¼‰
            const rotate90Chars = [
                'ãƒ¼', '-', 'â€¦', 'â€¥', '(', ')', 'ï¼ˆ', 'ï¼‰', '[', ']', 'ï¼»', 'ï¼½',
                '{', '}', 'ï½›', 'ï½', 'ã€ˆ', 'ã€‰', 'ã€Š', 'ã€‹', 'ã€Œ', 'ã€', 'ã€', 'ã€',
                'ã€', 'ã€‘', 'ã€”', 'ã€•', 'ï¼', 'ã€œ', 'ï½', ':', ';', 'ï¼š', 'ï¼›'
            ];

            if (char === 'ã€' || char === 'ã€‚') {
                details.x = fontSize * 0.45;
                details.y = -fontSize * 0.45;
                details.scale = 0.8; // å¥èª­ç‚¹ã¯è©°ã‚æ°—å‘³ã«ï¼ˆå°‘ã—åºƒã‚ã«èª¿æ•´ï¼‰
            } else if (rotate90Chars.includes(char)) {
                details.rotate = 90;
            } else if (['ã£', 'ã‚ƒ', 'ã‚…', 'ã‚‡', 'ã‚¡', 'ã‚£', 'ã‚¥', 'ã‚§', 'ã‚©', 'ãƒƒ', 'ãƒ£', 'ãƒ¥', 'ãƒ§'].includes(char)) {
                details.x = fontSize * 0.1;
                details.y = -fontSize * 0.1;
            }
            return details;
        }

        function drawText(element) {
            ctx.save();

            const x = element.x * displayScale;
            const y = element.y * displayScale;
            const fontSize = element.fontSize * displayScale;
            const baseLineHeight = fontSize * 1.1;

            // å›è»¢é©ç”¨
            ctx.translate(x, y);
            ctx.rotate((element.rotation || 0) * Math.PI / 180);
            ctx.translate(-x, -y);

            ctx.font = `${element.bold ? 'bold' : 'normal'} ${fontSize}px ${element.fontFamily}`;
            ctx.fillStyle = element.color;

            const lines = element.content.toString().split('\n').map(line => line.trimStart());

            if (element.vertical) {
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center';

                const totalWidth = lines.length * baseLineHeight;
                const startX = x + totalWidth / 2 - baseLineHeight / 2;

                // å…¨åˆ—ã®æœ€å¤§é«˜ã•ã‚’è¨ˆç®—ï¼ˆä¸Šæƒãˆã®ãŸã‚ï¼‰
                let maxColumnHeight = 0;
                const columnsDetails = lines.map(line => {
                    const chars = Array.from(line);
                    let colHeight = 0;
                    const details = chars.map(char => {
                        const d = getVerticalCharDetails(char, fontSize);
                        const h = baseLineHeight * d.scale;
                        colHeight += h;
                        return { ...d, height: h, char };
                    });
                    maxColumnHeight = Math.max(maxColumnHeight, colHeight);
                    return details; // å„åˆ—ã®è©³ç´°ãƒªã‚¹ãƒˆã‚’è¿”ã™
                });

                // æç”»é–‹å§‹ä¸€å¾‹Yä½ç½® (ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸Šç«¯ + å„æ–‡å­—ã‚ªãƒ•ã‚»ãƒƒãƒˆ)
                const blockTopY = y - maxColumnHeight / 2;

                columnsDetails.forEach((charDetailsList, lineIndex) => {
                    const lineX = startX - lineIndex * baseLineHeight;
                    let currentY = blockTopY;

                    charDetailsList.forEach((details) => {
                        const charY = currentY + details.height / 2;

                        ctx.save();
                        ctx.translate(lineX + details.x, charY + details.y);
                        if (details.rotate) {
                            ctx.rotate(details.rotate * Math.PI / 180);
                        }

                        if (element.stroke) {
                            ctx.strokeStyle = element.strokeColor;
                            ctx.lineWidth = element.strokeWidth * displayScale;
                            ctx.strokeText(details.char, 0, 0);
                        }
                        ctx.fillText(details.char, 0, 0);
                        ctx.restore();

                        currentY += details.height;
                    });
                });

            } else {
                // æ¨ªæ›¸ã
                ctx.textBaseline = 'middle';
                const lineHeight = fontSize * 1.2;

                // ãƒ–ãƒ­ãƒƒã‚¯å…¨ä½“ã®æœ€å¤§å¹…ã‚’è¨ˆç®—ï¼ˆå·¦æƒãˆã®ãŸã‚ï¼‰
                let maxLineWidth = 0;
                lines.forEach(line => {
                    const metrics = ctx.measureText(line);
                    maxLineWidth = Math.max(maxLineWidth, metrics.width);
                });

                ctx.textAlign = 'left'; // å·¦æƒãˆã§æç”»

                const totalHeight = lines.length * lineHeight;
                const startY = y - totalHeight / 2 + lineHeight / 2;
                const blockLeftX = x - maxLineWidth / 2;

                lines.forEach((line, index) => {
                    const lineY = startY + index * lineHeight;

                    if (element.stroke) {
                        ctx.strokeStyle = element.strokeColor;
                        ctx.lineWidth = element.strokeWidth * displayScale;
                        ctx.strokeText(line, blockLeftX, lineY);
                    }
                    ctx.fillText(line, blockLeftX, lineY);
                });
            }

            ctx.restore();
        }

        // å¹ãå‡ºã—æç”»ï¼ˆé›²ãƒ­ã‚¸ãƒƒã‚¯å‰Šé™¤ï¼‰
        function drawBubble(element, mode = 'full') {
            ctx.save();

            const x = element.x * displayScale;
            const y = element.y * displayScale;
            const width = element.width * displayScale;
            const height = element.height * displayScale;

            // é€éå‡¦ç†
            ctx.globalAlpha = element.opacity || 1.0;

            ctx.fillStyle = element.color;
            ctx.strokeStyle = element.borderColor;
            ctx.lineWidth = 2 * displayScale;

            ctx.beginPath();
            let isVector = true;

            if (element.shape === 'rect') {
                ctx.rect(x - width / 2, y - height / 2, width, height);
            } else if (element.shape === 'round') {
                // æ¥•å††
                ctx.ellipse(x, y, width / 2, height / 2, 0, 0, Math.PI * 2);
            } else if (element.shape === 'flash') {
                // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
                const spikes = 80;
                const outerRadiusX = width / 2;
                const outerRadiusY = height / 2;
                const innerRadiusX = width / 2 * 0.85;
                const innerRadiusY = height / 2 * 0.85;

                let rot = Math.PI / 2 * 3;
                let step = Math.PI / spikes;

                ctx.moveTo(x, y - outerRadiusY);
                for (let i = 0; i < spikes; i++) {
                    let cx = x + Math.cos(rot) * outerRadiusX;
                    let cy = y + Math.sin(rot) * outerRadiusY;
                    ctx.lineTo(cx, cy);
                    rot += step;

                    cx = x + Math.cos(rot) * innerRadiusX;
                    cy = y + Math.sin(rot) * innerRadiusY;
                    ctx.lineTo(cx, cy);
                    rot += step;
                }
                ctx.lineTo(x, y - outerRadiusY);
                ctx.closePath();
            } else if (element.shape === 'custom' && element.imageObj) {
                // ã‚«ã‚¹ã‚¿ãƒ ç”»åƒæç”»
                isVector = false;
                if (mode !== 'stroke') {
                    try {
                        ctx.drawImage(element.imageObj, x - width / 2, y - height / 2, width, height);
                    } catch (e) {
                        console.error('Image draw error', e);
                    }
                }
            }

            if (isVector) {
                if (mode !== 'stroke') ctx.fill();
                if (mode !== 'fill') ctx.stroke();
            }

            ctx.restore();
        }

        // é¸æŠãƒãƒ³ãƒ‰ãƒ«æç”»
        function drawSelectionHandles(element) {
            ctx.save();

            let bounds = getElementBounds(element); // å›è»¢å‰ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚µã‚¤ã‚ºãŒå¿…è¦ã ãŒ...
            // getElementBoundsã¯ã€Œæœªå›è»¢ã®çŠ¶æ…‹ã§ã®ã‚µã‚¤ã‚ºã€ã‚’è¿”ã™ã®ãŒç†æƒ³ã€‚
            // æ—¢å­˜ã®getElementBoundsã¯åº§æ¨™è¨ˆç®—ã‚’å«ã‚€ã®ã§ã€ã“ã“ã§ã¯ã€Œã‚µã‚¤ã‚ºã€ã ã‘ä½¿ã£ã¦ä¸­å¿ƒã‹ã‚‰æç”»ã™ã‚‹ã€‚

            const x = element.x * displayScale;
            const y = element.y * displayScale;
            const width = bounds.width * displayScale;
            const height = bounds.height * displayScale;

            // å›è»¢é©ç”¨
            ctx.translate(x, y);
            ctx.rotate((element.rotation || 0) * Math.PI / 180);

            // ä¸­å¿ƒåŸºæº–ã§çŸ©å½¢ã‚’æç”»
            const rectX = -width / 2;
            const rectY = -height / 2;

            // å¢ƒç•Œç·š
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(rectX, rectY, width, height);

            // ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«
            ctx.fillStyle = '#667eea';
            ctx.setLineDash([]); // ç‚¹ç·šè§£é™¤

            const handleSize = 8;
            ctx.fillRect(rectX - handleSize / 2, rectY - handleSize / 2, handleSize, handleSize);
            ctx.fillRect(rectX + width - handleSize / 2, rectY - handleSize / 2, handleSize, handleSize);
            ctx.fillRect(rectX - handleSize / 2, rectY + height - handleSize / 2, handleSize, handleSize);
            ctx.fillRect(rectX + width - handleSize / 2, rectY + height - handleSize / 2, handleSize, handleSize);

            // å›è»¢ãƒãƒ³ãƒ‰ãƒ«ï¼ˆä¸Šéƒ¨ä¸­å¤®ã‹ã‚‰ä¸Šã«çªãå‡ºã™ï¼‰
            const rotHandleDist = 25;
            const rotHandleSize = 10;
            ctx.beginPath();
            ctx.moveTo(0, rectY);
            ctx.lineTo(0, rectY - rotHandleDist);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(0, rectY - rotHandleDist, rotHandleSize / 2, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.stroke();

            ctx.restore();
        }

        // è¦ç´ ã®å¢ƒç•Œå–å¾—
        function getElementBounds(element) {
            if (element.type === 'text') {
                ctx.font = `${element.bold ? 'bold' : 'normal'} ${element.fontSize}px ${element.fontFamily}`;

                const lines = element.content.toString().split('\n').map(line => line.trimStart());
                const padding = element.fontSize * 0.2;

                if (element.vertical) {
                    const baseLineHeight = element.fontSize * 1.1;
                    const width = lines.length * baseLineHeight; // åˆ—å¹…ã¯ä¸€å®šã¨ã™ã‚‹

                    let maxColumnHeight = 0;
                    lines.forEach(line => {
                        let colHeight = 0;
                        Array.from(line).forEach(char => {
                            const d = getVerticalCharDetails(char, element.fontSize);
                            colHeight += baseLineHeight * d.scale;
                        });
                        maxColumnHeight = Math.max(maxColumnHeight, colHeight);
                    });

                    return {
                        x: element.x - width / 2 - padding,
                        y: element.y - maxColumnHeight / 2 - padding,
                        width: width + padding * 2,
                        height: maxColumnHeight + padding * 2
                    };
                } else {
                    const lineHeight = element.fontSize * 1.2;
                    // æ¨ªæ›¸ã: å¹… = æœ€ã‚‚é•·ã„è¡Œã®å¹…, é«˜ã• = è¡Œæ•° * è¡Œé«˜
                    let maxWidth = 0;
                    lines.forEach(line => {
                        const metrics = ctx.measureText(line);
                        maxWidth = Math.max(maxWidth, metrics.width);
                    });
                    const height = lines.length * lineHeight;

                    return {
                        x: element.x - maxWidth / 2 - padding,
                        y: element.y - height / 2 - padding,
                        width: maxWidth + padding * 2,
                        height: height + padding * 2
                    };
                }
            } else if (element.type === 'bubble') {
                return {
                    x: element.x - element.width / 2,
                    y: element.y - element.height / 2,
                    width: element.width,
                    height: element.height
                };
            }
        }

        // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
        // å›è»¢ãƒãƒ³ãƒ‰ãƒ«ã®åˆ¤å®š
        function isPointInRotationHandle(x, y, element) {
            const bounds = getElementBounds(element);
            const rotHandleDist = 25 * displayScale; // Scaled distance
            const rotHandleSize = 10 * displayScale; // Scaled size

            // ãƒã‚¦ã‚¹åº§æ¨™ã‚’è¦ç´ ã®ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ç³»ã«å¤‰æ›
            const elementCenterX = element.x * displayScale;
            const elementCenterY = element.y * displayScale;

            const dx = x - elementCenterX;
            const dy = y - elementCenterY;

            const angleRad = -(element.rotation || 0) * Math.PI / 180;
            const rotatedX = dx * Math.cos(angleRad) - dy * Math.sin(angleRad);
            const rotatedY = dx * Math.sin(angleRad) + dy * Math.cos(angleRad);

            // å›è»¢ãƒãƒ³ãƒ‰ãƒ«ä½ç½®ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã€å›è»¢å‰ï¼‰
            // ä¸Šéƒ¨ä¸­å¤® (0, -height/2) ã‹ã‚‰ã•ã‚‰ã«ä¸Šã« rotHandleDist
            const handleX = 0;
            const handleY = -bounds.height * displayScale / 2 - rotHandleDist;
            const dist = Math.sqrt(Math.pow(rotatedX - handleX, 2) + Math.pow(rotatedY - handleY, 2));

            return dist <= rotHandleSize / 2 + 5; // åŠå¾„ã‚ˆã‚Šå°‘ã—å¤§ãã‚ã«åˆ¤å®š
        }

        canvas.addEventListener('mousedown', function (e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / displayScale;
            const mouseY = (e.clientY - rect.top) / displayScale;

            // 1. å›è»¢ãƒãƒ³ãƒ‰ãƒ«ã®åˆ¤å®š
            if (selectedElement && isPointInRotationHandle(e.clientX - rect.left, e.clientY - rect.top, selectedElement)) {
                isRotating = true;
                // å›è»¢é–‹å§‹æ™‚ã®ãƒã‚¦ã‚¹ã¨è¦ç´ ä¸­å¿ƒã®è§’åº¦ã‚’è¨ˆç®—
                const elementCenterX = selectedElement.x * displayScale;
                const elementCenterY = selectedElement.y * displayScale;
                const initialAngleRad = Math.atan2(e.clientY - rect.top - elementCenterY, e.clientX - rect.left - elementCenterX);
                initialRotationOffset = initialAngleRad - (selectedElement.rotation || 0) * Math.PI / 180;
                return;
            }

            // 2. ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ã®åˆ¤å®š
            if (selectedElement && selectedElements.length <= 1) {
                const handle = getResizeHandle(mouseX, mouseY, selectedElement);
                if (handle) {
                    isResizing = true;
                    resizeHandle = handle;
                    dragStartX = mouseX;
                    dragStartY = mouseY;
                    return;
                }
            }

            // 3. è¦ç´ é¸æŠãƒ»ãƒ‰ãƒ©ãƒƒã‚°
            let clickedElement = null;
            for (let i = elements.length - 1; i >= 0; i--) {
                if (isPointInElement(mouseX, mouseY, elements[i])) {
                    clickedElement = elements[i];
                    break;
                }
            }

            if (clickedElement) {
                isDragging = true;
                dragStartX = mouseX;
                dragStartY = mouseY;

                if (e.ctrlKey || e.metaKey) {
                    const index = selectedElements.indexOf(clickedElement);
                    if (index >= 0) {
                        selectedElements.splice(index, 1);
                        if (clickedElement === selectedElement) {
                            selectedElement = selectedElements.length > 0 ? selectedElements[selectedElements.length - 1] : null;
                        }
                    } else {
                        selectedElements.push(clickedElement);
                        selectedElement = clickedElement;
                    }
                } else {
                    if (!selectedElements.includes(clickedElement)) {
                        selectedElements = [clickedElement];
                        selectedElement = clickedElement;
                    } else {
                        selectedElement = clickedElement;
                    }
                }
            } else {
                if (!e.ctrlKey && !e.metaKey) {
                    selectedElements = [];
                    selectedElement = null;
                }
            }

            updateProperties();
            render();
        });

        canvas.addEventListener('mousemove', function (e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / displayScale;
            const mouseY = (e.clientY - rect.top) / displayScale;

            // ã‚«ãƒ¼ã‚½ãƒ«è¡¨ç¤º
            if (!isDragging && !isResizing && !isRotating && selectedElement && selectedElements.length <= 1) {
                const handle = getResizeHandle(mouseX, mouseY, selectedElement);
                if (handle === 'se' || handle === 'nw') {
                    canvas.style.cursor = 'nwse-resize';
                } else if (handle === 'sw' || handle === 'ne') {
                    canvas.style.cursor = 'nesw-resize';
                } else if (isPointInRotationHandle(e.clientX - rect.left, e.clientY - rect.top, selectedElement)) {
                    canvas.style.cursor = 'grab'; // å›è»¢ã‚«ãƒ¼ã‚½ãƒ«
                }
                else {
                    canvas.style.cursor = 'crosshair';
                }
            } else if (!isDragging && !isResizing && !isRotating) {
                canvas.style.cursor = 'crosshair';
            }

            if (isResizing && selectedElement) {
                const dx = mouseX - dragStartX;
                const dy = mouseY - dragStartY;

                if (selectedElement.type === 'bubble') {
                    if (resizeHandle === 'se') {
                        selectedElement.width = Math.max(50, selectedElement.width + dx);
                        selectedElement.height = Math.max(50, selectedElement.height + dy);
                        selectedElement.x += dx / 2;
                        selectedElement.y += dy / 2;
                    } else if (resizeHandle === 'sw') {
                        selectedElement.width = Math.max(50, selectedElement.width - dx);
                        selectedElement.height = Math.max(50, selectedElement.height + dy);
                        selectedElement.x += dx / 2;
                        selectedElement.y += dy / 2;
                    } else if (resizeHandle === 'ne') {
                        selectedElement.width = Math.max(50, selectedElement.width + dx);
                        selectedElement.height = Math.max(50, selectedElement.height - dy);
                        selectedElement.x += dx / 2;
                        selectedElement.y += dy / 2;
                    } else if (resizeHandle === 'nw') {
                        selectedElement.width = Math.max(50, selectedElement.width - dx);
                        selectedElement.height = Math.max(50, selectedElement.height - dy);
                        selectedElement.x += dx / 2;
                        selectedElement.y += dy / 2;
                    }
                } else if (selectedElement.type === 'text') {
                    // ãƒãƒ³ãƒ‰ãƒ«ä½ç½®ã«å¿œã˜ã¦ãƒ‰ãƒ©ãƒƒã‚°é‡ã®ç¬¦å·ã‚’èª¿æ•´
                    let delta = 0;
                    if (resizeHandle === 'se') {
                        delta = dx + dy;
                    } else if (resizeHandle === 'sw') {
                        delta = -dx + dy;
                    } else if (resizeHandle === 'ne') {
                        delta = dx - dy;
                    } else if (resizeHandle === 'nw') {
                        delta = -dx - dy;
                    }

                    const scaleFactor = 1 + delta / 100;

                    // å°æ•°ç‚¹ä»¥ä¸‹ã‚‚ä¿æŒã™ã‚‹ã‚ˆã†ã«Math.roundã‚’å‰Šé™¤
                    const newFontSize = Math.max(10, Math.min(200, selectedElement.fontSize * scaleFactor));
                    selectedElement.fontSize = newFontSize;
                    document.getElementById('fontSize').value = Math.round(selectedElement.fontSize); // è¡¨ç¤ºã¯è¦‹ã‚„ã™ãæ•´æ•°ã§
                }

                dragStartX = mouseX;
                dragStartY = mouseY;
                render();
            } else if (isDragging && selectedElements.length > 0) {
                const dx = mouseX - dragStartX;
                const dy = mouseY - dragStartY;

                selectedElements.forEach(el => {
                    el.x += dx;
                    el.y += dy;
                });

                dragStartX = mouseX;
                dragStartY = mouseY;
                render();
            } else if (isRotating && selectedElement) {
                const elementCenterX = selectedElement.x * displayScale;
                const elementCenterY = selectedElement.y * displayScale;
                const currentAngleRad = Math.atan2(e.clientY - rect.top - elementCenterY, e.clientX - rect.left - elementCenterX);

                let newRotationRad = currentAngleRad - initialRotationOffset;
                let newRotationDeg = newRotationRad * 180 / Math.PI;

                // 5åº¦å˜ä½ã§ã‚¹ãƒŠãƒƒãƒ—
                if (e.shiftKey) {
                    newRotationDeg = Math.round(newRotationDeg / 5) * 5;
                }

                selectedElement.rotation = newRotationDeg;
                render();
            }
        });

        canvas.addEventListener('mouseup', function () {
            isDragging = false;
            isResizing = false;
            isRotating = false;
            resizeHandle = null;
        });

        function getResizeHandle(x, y, element) {
            const bounds = getElementBounds(element);
            const handleSize = 10;

            // ãƒã‚¦ã‚¹åº§æ¨™ã‚’è¦ç´ ã®ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ç³»ã«å¤‰æ›
            const elementCenterX = element.x;
            const elementCenterY = element.y;

            const dx = x - elementCenterX;
            const dy = y - elementCenterY;

            const angleRad = -(element.rotation || 0) * Math.PI / 180;
            const rotatedX = dx * Math.cos(angleRad) - dy * Math.sin(angleRad);
            const rotatedY = dx * Math.sin(angleRad) + dy * Math.cos(angleRad);

            // ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã§ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹
            const rectX = -bounds.width / 2;
            const rectY = -bounds.height / 2;
            const width = bounds.width;
            const height = bounds.height;

            if (Math.abs(rotatedX - (rectX + width)) < handleSize &&
                Math.abs(rotatedY - (rectY + height)) < handleSize) {
                return 'se';
            }
            if (Math.abs(rotatedX - rectX) < handleSize &&
                Math.abs(rotatedY - (rectY + height)) < handleSize) {
                return 'sw';
            }
            if (Math.abs(rotatedX - (rectX + width)) < handleSize &&
                Math.abs(rotatedY - rectY) < handleSize) {
                return 'ne';
            }
            if (Math.abs(rotatedX - rectX) < handleSize &&
                Math.abs(rotatedY - rectY) < handleSize) {
                return 'nw';
            }

            return null;
        }

        function isPointInElement(x, y, element) {
            const bounds = getElementBounds(element);
            return x >= bounds.x && x <= bounds.x + bounds.width &&
                y >= bounds.y && y <= bounds.y + bounds.height;
        }

        // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£æ›´æ–°
        function updateProperties() {
            if (!selectedElement) return;

            if (selectedElement.type === 'text') {
                document.getElementById('textContent').value = selectedElement.content;
                document.getElementById('fontSize').value = selectedElement.fontSize;
                document.getElementById('fontFamily').value = selectedElement.fontFamily;
                document.getElementById('textColor').value = selectedElement.color;
                document.getElementById('boldText').checked = selectedElement.bold;
                document.getElementById('strokeText').checked = selectedElement.stroke;
                document.getElementById('strokeColor').value = selectedElement.strokeColor;
                document.getElementById('strokeWidth').value = selectedElement.strokeWidth;

                document.getElementById('horizontalText').checked = !selectedElement.vertical; // ç¸¦æ›¸ãã®é€†

                // ç¸å–ã‚Šã‚ªãƒ—ã‚·ãƒ§ãƒ³è¡¨ç¤ºæ›´æ–°
                document.getElementById('strokeOptions').style.display = selectedElement.stroke ? 'flex' : 'none';
            } else if (selectedElement.type === 'bubble') {
                document.getElementById('bubbleColor').value = selectedElement.color;
                document.getElementById('bubbleBorderColor').value = selectedElement.borderColor;
                const opacity = Math.round((selectedElement.opacity || 1.0) * 100);
                document.getElementById('bubbleOpacity').value = opacity;
                document.getElementById('opacityValue').textContent = opacity;
            }
        }

        // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆ
        document.getElementById('textContent').addEventListener('input', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.content = this.value;
                render();
            }
        });

        document.getElementById('fontSize').addEventListener('input', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.fontSize = parseInt(this.value);
                render();
            }
        });

        document.getElementById('fontFamily').addEventListener('change', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.fontFamily = this.value;
                render();
            }
        });

        document.getElementById('textColor').addEventListener('input', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.color = this.value;
                render();
            }
        });

        document.getElementById('boldText').addEventListener('change', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.bold = this.checked;
                render();
            }
        });

        document.getElementById('strokeText').addEventListener('change', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.stroke = this.checked;
                render();
            }
        });

        document.getElementById('horizontalText').addEventListener('change', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.vertical = !this.checked; // ãƒã‚§ãƒƒã‚¯æ™‚ã¯æ¨ªæ›¸ã(vertical=false)
                render();
            }
        });

        document.getElementById('strokeColor').addEventListener('input', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.strokeColor = this.value;
                render();
            }
        });

        document.getElementById('strokeWidth').addEventListener('input', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.strokeWidth = parseInt(this.value);
                render();
            }
        });

        document.getElementById('bubbleColor').addEventListener('input', function () {
            if (selectedElement && selectedElement.type === 'bubble') {
                selectedElement.color = this.value;
                render();
            }
        });

        document.getElementById('bubbleBorderColor').addEventListener('input', function () {
            if (selectedElement && selectedElement.type === 'bubble') {
                selectedElement.borderColor = this.value;
                render();
            }
        });

        document.getElementById('bubbleOpacity').addEventListener('input', function () {
            if (selectedElement && selectedElement.type === 'bubble') {
                const opacity = parseInt(this.value) / 100;
                selectedElement.opacity = opacity;
                document.getElementById('opacityValue').textContent = this.value;
                render();
            }
        });

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†
        function updateLayerList() {
            const layerList = document.getElementById('layerList');
            layerList.innerHTML = '';

            elements.slice().reverse().forEach((element, index) => {
                const actualIndex = elements.length - 1 - index;
                const div = document.createElement('div');
                div.className = 'layer-item' + (selectedElements.includes(element) ? ' selected' : '');
                div.onclick = function (e) {
                    if (e.ctrlKey || e.metaKey) {
                        const idx = selectedElements.indexOf(element);
                        if (idx >= 0) {
                            selectedElements.splice(idx, 1);
                            if (element === selectedElement) {
                                selectedElement = selectedElements.length > 0 ? selectedElements[selectedElements.length - 1] : null;
                            }
                        } else {
                            selectedElements.push(element);
                            selectedElement = element;
                        }
                    } else {
                        selectedElement = element;
                        selectedElements = [element];
                    }
                    updateProperties();
                    render();
                };

                const name = element.type === 'text' ?
                    `ğŸ“ ${element.content.substring(0, 10)}` :
                    `ğŸ’­ ${element.shape}å¹ãå‡ºã—`;

                div.innerHTML = `
                    <span>${name}</span>
                    <span style="font-size: 0.8em; color: #999;">Layer ${actualIndex + 1}</span>
                `;

                layerList.appendChild(div);
            });
        }

        function moveToFront() {
            if (!selectedElement) return;
            const index = elements.indexOf(selectedElement);
            if (index !== -1 && index < elements.length - 1) {
                elements.splice(index, 1);
                elements.push(selectedElement);
                render();
            }
        }

        function moveToBack() {
            if (!selectedElement) return;
            const index = elements.indexOf(selectedElement);
            if (index > 0) {
                elements.splice(index, 1);
                elements.unshift(selectedElement);
                render();
            }
        }

        function deleteSelected() {
            if (selectedElements.length === 0) return;

            elements = elements.filter(el => !selectedElements.includes(el));

            selectedElements = [];
            selectedElement = null;
            updateProperties();
            render();
        }

        // ä¿å­˜ãƒ»èª­è¾¼
        function saveProject() {
            if (!originalImage) {
                alert('ä¿å­˜ã™ã‚‹ç”»åƒãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }

            const data = {
                imageData: originalImage.src,
                elements: elements
            };

            const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'project.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function (e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (event) {
                        const data = JSON.parse(event.target.result);

                        const img = new Image();
                        img.onload = function () {
                            originalImage = img;
                            canvas.width = img.width * displayScale;
                            canvas.height = img.height * displayScale;
                            elements = data.elements;
                            selectedElement = null;
                            selectedElements = [];
                            render();
                        };
                        img.src = data.imageData;
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function exportImage() {
            if (!originalImage) {
                alert('å‡ºåŠ›ã™ã‚‹ç”»åƒãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }

            // å…ƒã®è§£åƒåº¦ã§ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆ
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = originalImage.width;
            exportCanvas.height = originalImage.height;
            const exportCtx = exportCanvas.getContext('2d');

            // ç”»åƒã‚’æç”»
            exportCtx.drawImage(originalImage, 0, 0);

            // è¦ç´ ã‚’å…ƒã®ã‚¹ã‚±ãƒ¼ãƒ«ã§æç”»
            const originalScale = displayScale;
            displayScale = 1.0;

            // å¹ãå‡ºã—ãƒ¬ã‚¤ãƒ¤ãƒ¼æç”»
            const allBubbles = elements.filter(el => el.type === 'bubble');
            const MERGEABLE_SHAPES = ['rect', 'round', 'flash'];
            const mergeBubbles = allBubbles.filter(el => MERGEABLE_SHAPES.includes(el.shape));
            const customBubbles = allBubbles.filter(el => !MERGEABLE_SHAPES.includes(el.shape));

            if (mergeBubbles.length > 0) {
                const exBubbleCanvas = document.createElement('canvas');
                exBubbleCanvas.width = exportCanvas.width;
                exBubbleCanvas.height = exportCanvas.height;
                const exBubbleCtx = exBubbleCanvas.getContext('2d');

                // Pass 1: Stroke
                mergeBubbles.forEach(element => {
                    drawBubbleOnCtx(exBubbleCtx, element, 'stroke', 1.0, 1.0);
                });

                // Pass 2: Fill
                mergeBubbles.forEach(element => {
                    exBubbleCtx.save();
                    exBubbleCtx.globalCompositeOperation = 'destination-out';
                    drawBubblePath(exBubbleCtx, element, 1.0);
                    exBubbleCtx.fillStyle = 'black';
                    exBubbleCtx.globalAlpha = 1.0;
                    exBubbleCtx.fill();
                    exBubbleCtx.restore();

                    drawBubbleOnCtx(exBubbleCtx, element, 'fill', 1.0, 1.0);
                });

                let groupOpacity = mergeBubbles[mergeBubbles.length - 1].opacity;
                if (groupOpacity === undefined) groupOpacity = 1.0;

                exportCtx.save();
                exportCtx.globalAlpha = groupOpacity;
                exportCtx.drawImage(exBubbleCanvas, 0, 0);
                exportCtx.restore();
            }

            // Custom Bubbles
            customBubbles.forEach(element => {
                const opacity = element.opacity !== undefined ? element.opacity : 1.0;
                drawBubbleOnCtx(exportCtx, element, 'image', opacity, 1.0);
            });

            // ãƒ†ã‚­ã‚¹ãƒˆæç”»
            elements.forEach(element => {
                if (element.type === 'text') {
                    exportCtx.save();

                    // å›è»¢é©ç”¨
                    exportCtx.translate(element.x, element.y);
                    exportCtx.rotate((element.rotation || 0) * Math.PI / 180);
                    exportCtx.translate(-element.x, -element.y);

                    exportCtx.font = `${element.bold ? 'bold' : 'normal'} ${element.fontSize}px ${element.fontFamily}`;
                    exportCtx.fillStyle = element.color;
                    const lines = element.content.toString().split('\n').map(line => line.trimStart());

                    if (element.vertical) {
                        // ç¸¦æ›¸ã
                        exportCtx.textBaseline = 'middle';
                        exportCtx.textAlign = 'center';
                        const baseLineHeight = element.fontSize * 1.1;

                        const totalWidth = lines.length * baseLineHeight;
                        const startX = element.x + totalWidth / 2 - baseLineHeight / 2;

                        // å…¨åˆ—ã®æœ€å¤§é«˜ã•ã‚’è¨ˆç®—
                        let maxColumnHeight = 0;
                        const columnsDetails = lines.map(line => {
                            const chars = Array.from(line);
                            let colHeight = 0;
                            const details = chars.map(char => {
                                const d = getVerticalCharDetails(char, element.fontSize);
                                const h = baseLineHeight * d.scale;
                                colHeight += h;
                                return { ...d, height: h, char };
                            });
                            maxColumnHeight = Math.max(maxColumnHeight, colHeight);
                            return details;
                        });

                        const blockTopY = element.y - maxColumnHeight / 2;

                        columnsDetails.forEach((charDetailsList, lineIndex) => {
                            const lineX = startX - lineIndex * baseLineHeight;
                            let currentY = blockTopY;

                            charDetailsList.forEach(details => {
                                const charY = currentY + details.height / 2;

                                exportCtx.save();
                                exportCtx.translate(lineX + details.x, charY + details.y);
                                if (details.rotate) {
                                    exportCtx.rotate(details.rotate * Math.PI / 180);
                                }

                                if (element.stroke) {
                                    exportCtx.strokeStyle = element.strokeColor;
                                    exportCtx.lineWidth = element.strokeWidth;
                                    exportCtx.strokeText(details.char, 0, 0);
                                }
                                exportCtx.fillText(details.char, 0, 0);
                                exportCtx.restore();

                                currentY += details.height;
                            });
                        });
                    } else {
                        // æ¨ªæ›¸ã
                        exportCtx.textBaseline = 'middle';
                        const lineHeight = element.fontSize * 1.2;

                        // ãƒ–ãƒ­ãƒƒã‚¯å…¨ä½“ã®æœ€å¤§å¹…ã‚’è¨ˆç®—
                        let maxLineWidth = 0;
                        lines.forEach(line => {
                            const metrics = exportCtx.measureText(line);
                            maxLineWidth = Math.max(maxLineWidth, metrics.width);
                        });

                        exportCtx.textAlign = 'left';

                        const totalHeight = lines.length * lineHeight;
                        const startY = element.y - totalHeight / 2 + lineHeight / 2;
                        const blockLeftX = element.x - maxLineWidth / 2;

                        lines.forEach((line, index) => {
                            const lineY = startY + index * lineHeight;

                            if (element.stroke) {
                                exportCtx.strokeStyle = element.strokeColor;
                                exportCtx.lineWidth = element.strokeWidth;
                                exportCtx.strokeText(line, blockLeftX, lineY);
                            }
                            exportCtx.fillText(line, blockLeftX, lineY);
                        });
                    }
                    exportCtx.restore();
                }
                // Bubble rendering moved to layer composition
            });

            displayScale = originalScale;

            exportCanvas.toBlob(function (blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'output.png';
                a.click();
                URL.revokeObjectURL(url);
            }, 'image/png', 0.8); // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºå‰Šæ¸›ã®ãŸã‚å“è³ªèª¿æ•´
        }

        // ==========================================
        // ã‚«ã‚¹ã‚¿ãƒ ã‚¢ã‚»ãƒƒãƒˆç®¡ç†æ©Ÿèƒ½ (IndexedDB)
        // ==========================================

        const DB_NAME = 'ImageEditorAssets';
        const DB_VERSION = 1;
        let db = null;

        // DBåˆæœŸåŒ–
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = function (e) {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('fonts')) {
                        db.createObjectStore('fonts', { keyPath: 'id', autoIncrement: true });
                    }
                    if (!db.objectStoreNames.contains('bubbles')) {
                        db.createObjectStore('bubbles', { keyPath: 'id', autoIncrement: true });
                    }
                };

                request.onsuccess = function (e) {
                    db = e.target.result;
                    resolve(db);
                };

                request.onerror = function (e) {
                    console.error('DB Error', e);
                    reject(e);
                };
            });
        }

        // ãƒ‡ãƒ¼ã‚¿ã®è¿½åŠ 
        function addToDB(storeName, data) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.add(data);

                request.onsuccess = function (e) {
                    resolve(e.target.result);
                };

                request.onerror = function (e) {
                    reject(e);
                };
            });
        }

        // å…¨ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
        function getAllFromDB(storeName) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();

                request.onsuccess = function (e) {
                    resolve(e.target.result);
                };

                request.onerror = function (e) {
                    reject(e);
                };
            });
        }

        // ãƒ‡ãƒ¼ã‚¿ã®å‰Šé™¤
        function deleteFromDB(storeName, id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(id);

                request.onsuccess = function () {
                    resolve();
                };

                request.onerror = function (e) {
                    reject(e);
                };
            });
        }

        // åˆæœŸåŒ–å‡¦ç†
        initDB().then(() => {
            loadCustomFonts();
            loadCustomBubbles();
        });

        // ------------------------------------------
        // ãƒ•ã‚©ãƒ³ãƒˆç®¡ç†
        // ------------------------------------------

        document.getElementById('fontInput').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (evt) {
                const fontData = evt.target.result; // ArrayBuffer
                const fontName = file.name.replace(/\.[^/.]+$/, ""); // æ‹¡å¼µå­é™¤å»

                // ãƒ•ã‚©ãƒ³ãƒˆãƒ­ãƒ¼ãƒ‰
                loadFontToDocument(fontName, fontData).then(() => {
                    // DBä¿å­˜
                    addToDB('fonts', {
                        name: fontName,
                        content: fontData, // ãã®ã¾ã¾ä¿å­˜ã§ããªã„å ´åˆãŒã‚ã‚‹ãŒã€Blobæ¨å¥¨ã€‚ã“ã“ã§ã¯ArrayBuffer
                        fileName: file.name
                    }).then(() => {
                        loadCustomFonts(); // ãƒªã‚¹ãƒˆæ›´æ–°
                        alert(`ãƒ•ã‚©ãƒ³ãƒˆ "${fontName}" ã‚’è¿½åŠ ã—ã¾ã—ãŸ`);
                    });
                }).catch(err => {
                    alert('ãƒ•ã‚©ãƒ³ãƒˆã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    console.error(err);
                });
            };
            reader.readAsArrayBuffer(file);
            this.value = '';
        });

        async function loadCustomFonts() {
            const fonts = await getAllFromDB('fonts');
            const list = document.getElementById('customFontList');
            const select = document.getElementById('fontFamily');

            list.innerHTML = '';

            // æ—¢å­˜ã®ã‚«ã‚¹ã‚¿ãƒ ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ã‚¯ãƒªã‚¢ï¼ˆæ¨™æº–ä»¥å¤–ï¼‰
            let optGroup = select.querySelector('optgroup[label="ã‚«ã‚¹ã‚¿ãƒ "]');
            if (!optGroup) {
                optGroup = document.createElement('optgroup');
                optGroup.label = "ã‚«ã‚¹ã‚¿ãƒ ";
                select.appendChild(optGroup);
            }
            optGroup.innerHTML = ''; // ã‚¯ãƒªã‚¢

            for (const font of fonts) {
                // UIãƒªã‚¹ãƒˆã«è¿½åŠ  (è¡¨ç¤º)
                const div = document.createElement('div');
                div.style.display = 'flex';
                div.style.alignItems = 'center';
                div.style.justifyContent = 'space-between';
                div.style.background = '#f1f1f1';
                div.style.padding = '4px 8px';
                div.style.borderRadius = '4px';
                div.style.fontSize = '0.8em';

                div.innerHTML = `
                    <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${font.name}</span>
                    <span class="font-delete-btn" onclick="removeFont(${font.id})" style="margin-left: 10px; cursor: pointer; color: #ff5252;">âœ–</span>
                `;
                list.appendChild(div);

                // ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã«è¿½åŠ  (å¼•ç”¨ç¬¦ã§å›²ã‚€)
                const option = document.createElement('option');
                option.value = `"${font.name}"`; // ã‚¹ãƒšãƒ¼ã‚¹å¯¾å¿œã®ãŸã‚å¼•ç”¨ç¬¦ã§å›²ã‚€
                option.textContent = font.name;
                optGroup.appendChild(option);

                // ã¾ã ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ãƒ­ãƒ¼ãƒ‰
                if (!document.fonts.check(`12px "${font.name}"`)) {
                    loadFontToDocument(font.name, font.content);
                }
            }
        }

        function loadFontToDocument(name, data) {
            const fontFace = new FontFace(name, data);
            return fontFace.load().then(loadedFace => {
                document.fonts.add(loadedFace);
                return loadedFace;
            });
        }

        window.removeFont = function (id) {
            if (confirm('ã“ã®ãƒ•ã‚©ãƒ³ãƒˆã‚’å‰Šé™¤ã—ã¦ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) {
                deleteFromDB('fonts', id).then(() => {
                    loadCustomFonts();
                });
            }
        };

        // ------------------------------------------
        // å›è»¢ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        // ------------------------------------------
        document.getElementById('elementRotation').addEventListener('input', function (e) {
            if (selectedElement) {
                selectedElement.rotation = parseInt(e.target.value);
                document.getElementById('rotationValue').textContent = selectedElement.rotation;
                render();
            }
        });

        // ------------------------------------------
        // å¹ãå‡ºã—ç®¡ç†
        // ------------------------------------------

        document.getElementById('bubbleInput').addEventListener('change', function (e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;

            const promises = Array.from(files).map(file => {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = function (evt) {
                        const dataUrl = evt.target.result;
                        addToDB('bubbles', {
                            content: dataUrl,
                            name: file.name
                        }).then(resolve);
                    };
                    reader.readAsDataURL(file);
                });
            });

            Promise.all(promises).then(() => {
                loadCustomBubbles();
                this.value = '';
            });
        });

        async function loadCustomBubbles() {
            const bubbles = await getAllFromDB('bubbles');
            const list = document.getElementById('customBubbleList');
            list.innerHTML = '';

            for (const bubble of bubbles) {
                const div = document.createElement('div');
                div.className = 'custom-item';
                div.style.backgroundImage = `url(${bubble.content})`;

                // å‰Šé™¤ãƒœã‚¿ãƒ³
                const delBtn = document.createElement('div');
                delBtn.className = 'delete-btn';
                delBtn.textContent = 'âœ•';
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    removeBubble(bubble.id);
                };
                div.appendChild(delBtn);

                // ã‚¯ãƒªãƒƒã‚¯ã§è¿½åŠ 
                div.onclick = () => {
                    addCustomBubble(bubble.content);
                };

                // ãƒ›ãƒãƒ¼ã§ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
                div.addEventListener('mousemove', (e) => {
                    const popup = document.getElementById('previewPopup');
                    const img = document.getElementById('previewImage');
                    popup.style.display = 'flex';
                    popup.style.left = (e.clientX + 15) + 'px';
                    popup.style.top = (e.clientY + 15) + 'px';
                    if (img.src !== bubble.content) {
                        img.src = bubble.content;
                    }
                });

                div.addEventListener('mouseleave', () => {
                    document.getElementById('previewPopup').style.display = 'none';
                });

                list.appendChild(div);
            }
        }

        window.removeBubble = function (id) {
            if (confirm('ã“ã®å¹ãå‡ºã—ç”»åƒã‚’å‰Šé™¤ã—ã¦ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) {
                deleteFromDB('bubbles', id).then(() => {
                    loadCustomBubbles();
                });
            }
        };

        function addCustomBubble(dataUrl) {
            if (!originalImage) {
                alert('å…ˆã«ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„');
                return;
            }

            const img = new Image();
            img.onload = function () {
                const element = {
                    type: 'bubble',
                    shape: 'custom',
                    // ç”»åƒã®èª­ã¿è¾¼ã¿ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦åˆæœŸã‚µã‚¤ã‚ºæ±ºå®šï¼ˆå¤§ãã™ããªã„ã‚ˆã†ã«åˆ¶é™ï¼‰
                    width: Math.min(200, img.width),
                    height: Math.min(150, img.width * (img.height / img.width)),
                    x: canvas.width / 2 / displayScale,
                    y: canvas.height / 2 / displayScale,
                    color: '#ffffff', // ã‚«ã‚¹ã‚¿ãƒ ç”»åƒã«ã¯åŠ¹ã‹ãªã„ãŒãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ä¿æŒ
                    borderColor: '#000000',
                    opacity: 1.0,
                    source: dataUrl, // ä¿å­˜ç”¨DataURL
                    imageObj: img // æç”»ç”¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
                };

                // ã‚µã‚¤ã‚ºãŒå°ã•ã™ãã‚‹å ´åˆã®è£œæ­£
                if (element.width < 50) element.width = 50;
                if (element.height < 50) element.height = 50;

                if (element.width < 50) element.width = 50;
                if (element.height < 50) element.height = 50;

                elements.push(element);
                selectedElement = element;
                selectedElements = [element];
                updateProperties();
                render();
            };
            img.src = dataUrl;
        }

        // ä¿å­˜ãƒ»èª­è¾¼ã®ä¿®æ­£ï¼ˆã‚«ã‚¹ã‚¿ãƒ å¹ãå‡ºã—å¯¾å¿œï¼‰
        const originalLoadProject = window.loadProject;

        window.loadProject = function () {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function (e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (event) {
                        const data = JSON.parse(event.target.result);

                        const img = new Image();
                        img.onload = function () {
                            originalImage = img;
                            canvas.width = img.width * displayScale;
                            canvas.height = img.height * displayScale;

                            // è¦ç´ ã®å¾©å…ƒ
                            elements = [];
                            const loadPromises = data.elements.map(el => {
                                return new Promise((resolve) => {
                                    if (el.type === 'bubble' && el.shape === 'custom' && el.source) {
                                        const customImg = new Image();
                                        customImg.onload = function () {
                                            el.imageObj = customImg;
                                            resolve(el);
                                        };
                                        customImg.onerror = function () {
                                            el.shape = 'rect';
                                            resolve(el);
                                        }
                                        customImg.src = el.source;
                                    } else {
                                        resolve(el);
                                    }
                                });
                            });

                            Promise.all(loadPromises).then(loadedElements => {
                                elements = loadedElements;
                                selectedElement = null;
                                selectedElements = [];
                                render();
                            });
                        };
                        img.src = data.imageData;
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        };

    </script>
</body>

</html>