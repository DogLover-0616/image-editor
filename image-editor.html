<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç”»åƒã‚¨ãƒ‡ã‚£ã‚¿ - ãƒ†ã‚­ã‚¹ãƒˆï¼†å¹ãå‡ºã—è¿½åŠ </title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .toolbar-group {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 12px 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .toolbar-group label {
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
            white-space: nowrap;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            white-space: nowrap;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
        }

        button.secondary:hover {
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.6);
        }

        input[type="file"] {
            padding: 8px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: white;
            cursor: pointer;
        }

        input[type="text"],
        input[type="number"],
        select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 0.95em;
            transition: border-color 0.3s ease;
            width: 100%;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            padding: 2px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .canvas-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            align-items: flex-start;
        }

        .canvas-wrapper {
            flex: 1;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
            overflow: auto;
            max-height: 80vh;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 500px;
        }

        #canvas {
            border: 2px solid #667eea;
            cursor: crosshair;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .properties-panel {
            width: 350px;
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
            max-height: 80vh;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .properties-panel h3 {
            color: #667eea;
            margin: 20px 0 15px 0;
            font-size: 1.2em;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 5px;
        }

        .properties-panel h3:first-child {
            margin-top: 0;
        }

        .property-group {
            margin-bottom: 15px;
        }

        .property-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        .horizontal-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .horizontal-group>* {
            flex: 1;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 5px;
            background: #f8f9fa;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #eee;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .checkbox-group:hover {
            background: #eef2f7;
            border-color: #cbd5e0;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-group label {
            margin-bottom: 0;
            cursor: pointer;
        }

        .control-btn {
            width: 100%;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .layer-list {
            max-height: 150px;
            overflow-y: auto;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 10px;
            border: 1px solid #eee;
        }

        .layer-item {
            padding: 8px 12px;
            margin-bottom: 5px;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
            border: 1px solid #eee;
            font-size: 0.9em;
        }

        .layer-item:hover {
            border-color: #667eea;
            transform: translateX(2px);
        }

        .layer-item.selected {
            background: #ebf4ff;
            border-color: #667eea;
            color: #2b6cb0;
            font-weight: 600;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.9em;
            color: #1976d2;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .container {
            animation: fadeIn 0.5s ease;
        }

        /* ã‚«ã‚¹ã‚¿ãƒ ã‚¢ã‚»ãƒƒãƒˆç®¡ç†ç”¨CSS */
        .custom-assets-area {
            margin-top: 10px;
            border-top: 1px dashed #ddd;
            padding-top: 10px;
            background: #fdfdfd;
            padding: 10px;
            border-radius: 8px;
        }

        .custom-file-input {
            display: none;
        }

        .custom-btn {
            font-size: 0.8em;
            padding: 5px 10px;
            background: #eee;
            color: #333;
            box-shadow: none;
            border: 1px solid #ddd;
        }

        .custom-btn:hover {
            background: #e0e0e0;
            transform: none;
            box-shadow: none;
        }

        .custom-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .custom-item {
            width: 50px;
            height: 50px;
            border: 2px solid #eee;
            border-radius: 5px;
            cursor: pointer;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            background-color: #fff;
            position: relative;
            transition: all 0.2s;
        }

        .custom-item:hover {
            border-color: #667eea;
        }

        .delete-btn {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 16px;
            height: 16px;
            background: #ff5252;
            color: white;
            border-radius: 50%;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            display: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        .custom-item:hover .delete-btn {
            display: flex;
            opacity: 1;
        }

        .preview-popup {
            position: fixed;
            border: 2px solid #667eea;
            background: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            pointer-events: none;
            display: none;
            border-radius: 10px;
            padding: 5px;
            width: 300px;
            /* å›ºå®šã‚µã‚¤ã‚º */
            height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .preview-popup img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .font-delete-btn {
            color: #ff5252;
            cursor: pointer;
            margin-left: 5px;
            font-size: 0.8em;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ¨ ç”»åƒã‚¨ãƒ‡ã‚£ã‚¿</h1>

        <div class="info-box">
            <span>ğŸ’¡ ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã§ç·¨é›†ã§ãã¾ã™ã€‚Deleteã‚­ãƒ¼ã§å‰Šé™¤ã€å››éš…ãƒãƒ³ãƒ‰ãƒ«ã§ãƒªã‚µã‚¤ã‚ºå¯èƒ½ã§ã™ã€‚</span>
        </div>

        <div class="toolbar">
            <!-- ç”»åƒèª­ã¿è¾¼ã¿ -->
            <div class="toolbar-group">
                <label>ğŸ“ ç”»åƒèª­è¾¼:</label>
                <input type="file" id="imageInput" accept="image/*">
            </div>

            <!-- ç·¨é›†ãƒ»ä¿å­˜ -->
            <div class="toolbar-group">
                <button class="secondary" onclick="deleteSelected()">ğŸ—‘ï¸ å‰Šé™¤</button>
                <button onclick="saveProject()">ğŸ’¾ ä¿å­˜</button>
                <button onclick="loadProject()">ğŸ“‚ èª­è¾¼</button>
                <button onclick="exportImage()">ğŸ“¥ å‡ºåŠ›</button>
            </div>
        </div>

        <div class="canvas-container">
            <div class="canvas-wrapper">
                <canvas id="canvas"></canvas>
            </div>

            <div class="properties-panel">
                <h3>ãƒ†ã‚­ã‚¹ãƒˆè¨­å®š</h3>

                <!-- 1. ãƒ†ã‚­ã‚¹ãƒˆæ¬„ -->
                <div class="property-group">
                    <input type="text" id="textContent" placeholder="ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„">
                </div>

                <!-- 2. å¤ªå­—ãƒ»ç¸å–ã‚Šãƒ»æ¨ªæ›¸ã (æ¨ªä¸¦ã³) -->
                <div class="property-group horizontal-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="boldText">
                        <label for="boldText">å¤ªå­—</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="strokeText">
                        <label for="strokeText">ç¸å–ã‚Š</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="horizontalText">
                        <label for="horizontalText">æ¨ªæ›¸ã</label>
                    </div>
                </div>

                <!-- ç¸å–ã‚Šã‚ªãƒ—ã‚·ãƒ§ãƒ³ -->
                <div class="property-group horizontal-group" id="strokeOptions" style="display:none;">
                    <div>
                        <label style="font-size:0.8em;">ç¸è‰²</label>
                        <input type="color" id="strokeColor" value="#ffffff" style="height:30px;">
                    </div>
                    <div style="flex:2;">
                        <label style="font-size:0.8em;">ç¸å¹…</label>
                        <input type="number" id="strokeWidth" value="3" min="1" max="20" style="padding:4px;">
                    </div>
                </div>

                <!-- 3. ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã¨ãƒ†ã‚­ã‚¹ãƒˆè‰² (æ¨ªä¸¦ã³) - ç§»å‹• -->
                <div class="property-group horizontal-group">
                    <div style="flex: 1;">
                        <label>ã‚µã‚¤ã‚º</label>
                        <input type="number" id="fontSize" value="32" min="10" max="200">
                    </div>
                    <div style="flex: 1;">
                        <label>è‰²</label>
                        <input type="color" id="textColor" value="#000000">
                    </div>
                </div>

                <!-- 4. ãƒ•ã‚©ãƒ³ãƒˆ - ç§»å‹• -->
                <div class="property-group">
                    <label>ãƒ•ã‚©ãƒ³ãƒˆ</label>
                    <select id="fontFamily">
                        <option value="'Yu Gothic', 'Meiryo', sans-serif">ã‚´ã‚·ãƒƒã‚¯ä½“</option>
                        <option value="'Yu Mincho', 'MS Mincho', serif">æ˜æœä½“</option>
                    </select>
                    <div class="custom-assets-area">
                        <label style="font-size: 0.8em; color: #666;">ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚©ãƒ³ãƒˆç®¡ç†</label>
                        <button class="custom-btn" onclick="document.getElementById('fontInput').click()">â•
                            ãƒ•ã‚©ãƒ³ãƒˆè¿½åŠ </button>
                        <input type="file" id="fontInput" class="custom-file-input" accept=".ttf,.woff,.woff2,font/*">
                        <div id="customFontList" style="margin-top: 5px; font-size: 0.8em; display: none;"></div>
                        <!-- éè¡¨ç¤ºã« -->
                    </div>
                </div>

                <!-- 5. ãƒ†ã‚­ã‚¹ãƒˆè¿½åŠ  -->
                <div class="property-group">
                    <button class="control-btn" onclick="addText()">ğŸ“ ãƒ†ã‚­ã‚¹ãƒˆè¿½åŠ </button>
                </div>

                <h3>å¹ãå‡ºã—è¨­å®š</h3>

                <!-- 6. å››è§’å¹ãå‡ºã—ã€ä¸¸å¹ãå‡ºã— (æ¨ªä¸¦ã³) -->
                <div class="property-group horizontal-group">
                    <button class="control-btn" onclick="addBubble('rect')">ğŸ’­ å››è§’</button>
                    <button class="control-btn" onclick="addBubble('round')">ğŸ’¬ ä¸¸</button>
                    <button class="control-btn" onclick="addBubble('flash')">ğŸ’¥ ãƒ•ãƒ©ãƒƒã‚·ãƒ¥</button>
                </div>

                <div class="custom-assets-area">
                    <label style="font-size: 0.8em; color: #666;">ã‚«ã‚¹ã‚¿ãƒ å¹ãå‡ºã—</label>
                    <button class="custom-btn" onclick="document.getElementById('bubbleInput').click()">â• ç”»åƒè¿½åŠ </button>
                    <input type="file" id="bubbleInput" class="custom-file-input" accept="image/*">
                    <div id="customBubbleList" class="custom-list"></div>
                </div>

                <!-- 7. å¹ãå‡ºã—è‰²ãƒ»å¹ãå‡ºã—æ è‰² (æ¨ªä¸¦ã³) -->
                <div class="property-group horizontal-group">
                    <div style="flex: 1;">
                        <label>èƒŒæ™¯è‰²</label>
                        <input type="color" id="bubbleColor" value="#ffffff">
                    </div>
                    <div style="flex: 1;">
                        <label>æ è‰²</label>
                        <input type="color" id="bubbleBorderColor" value="#000000">
                    </div>
                </div>

                <!-- 8. å¹ãå‡ºã—é€æ˜åº¦ãƒãƒ¼ -->
                <div class="property-group">
                    <label>é€æ˜åº¦: <span id="opacityValue">100</span>%</label>
                    <input type="range" id="bubbleOpacity" min="0" max="100" value="100">
                </div>

                <h3>ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œ</h3>
                <div class="property-group">
                    <div class="horizontal-group" style="margin-bottom: 10px;">
                        <button onclick="moveToFront()">â¬†ï¸ å‰é¢</button>
                        <button onclick="moveToBack()">â¬‡ï¸ èƒŒé¢</button>
                    </div>
                    <div class="layer-list" id="layerList"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="previewPopup" class="preview-popup">
        <img id="previewImage" src="">
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // ç¸å–ã‚Šã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆç”¨
        const strokeTextCheckbox = document.getElementById('strokeText');
        const strokeOptions = document.getElementById('strokeOptions');
        strokeTextCheckbox.addEventListener('change', function () {
            strokeOptions.style.display = this.checked ? 'flex' : 'none';
        });

        let originalImage = null;
        let displayScale = 0.5;
        let elements = [];
        let selectedElement = null;
        let selectedElements = []; // è¤‡æ•°é¸æŠç”¨
        let isDragging = false;
        let isResizing = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let resizeHandle = null;

        let clipboard = null; // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ç”¨

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆ (Delete, Copy, Paste)
        document.addEventListener('keydown', function (e) {
            // Delete
            if (e.key === 'Delete' && selectedElement) {
                deleteSelected();
                return;
            }

            // Copy (Ctrl+C)
            if ((e.ctrlKey || e.metaKey) && e.key === 'c' && selectedElement) {
                // imageObjç­‰ã®å¾ªç’°å‚ç…§ã‚’é¿ã‘ã‚‹ãŸã‚ã€å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ã®ã¿ã‚³ãƒ”ãƒ¼
                const clone = JSON.parse(JSON.stringify(selectedElement));
                // ã‚«ã‚¹ã‚¿ãƒ ç”»åƒã®å ´åˆã¯sourceãŒå¿…è¦
                if (selectedElement.source) {
                    clone.source = selectedElement.source;
                }
                clipboard = clone;
                return;
            }

            // Paste (Ctrl+V)
            if ((e.ctrlKey || e.metaKey) && e.key === 'v' && clipboard) {
                const newElement = JSON.parse(JSON.stringify(clipboard));

                // ä½ç½®ã‚’å°‘ã—ãšã‚‰ã™
                newElement.x += 20;
                newElement.y += 20;

                // ã‚«ã‚¹ã‚¿ãƒ ç”»åƒã®å¾©å…ƒå‡¦ç†
                if (newElement.type === 'bubble' && newElement.shape === 'custom' && newElement.source) {
                    const img = new Image();
                    img.onload = function () {
                        newElement.imageObj = img;
                        elements.push(newElement);
                        selectedElement = newElement;
                        selectedElements = [newElement];
                        updateProperties();
                        render();
                    };
                    img.src = newElement.source;
                } else {
                    elements.push(newElement);
                    selectedElement = newElement;
                    selectedElements = [newElement];
                    updateProperties();
                    render();
                }
            }
        });

        // ç”»åƒèª­ã¿è¾¼ã¿
        document.getElementById('imageInput').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (event) {
                    const img = new Image();
                    img.onload = function () {
                        originalImage = img;
                        canvas.width = img.width * displayScale;
                        canvas.height = img.height * displayScale;
                        // æ–°ã—ã„ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã ã‚‰è¦ç´ ã‚’ãƒªã‚»ãƒƒãƒˆ
                        elements = [];
                        selectedElement = null;
                        selectedElements = [];
                        render();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // ãƒ†ã‚­ã‚¹ãƒˆè¿½åŠ 
        function addText() {
            if (!originalImage) {
                alert('å…ˆã«ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„');
                return;
            }

            // ç¾åœ¨ã®è¨­å®šå€¤ã‚’DOMã‹ã‚‰å–å¾—
            const currentFontSize = parseInt(document.getElementById('fontSize').value) || 32;
            const currentFontFamily = document.getElementById('fontFamily').value;
            const currentColor = document.getElementById('textColor').value;
            const isBold = document.getElementById('boldText').checked;
            const isStroke = document.getElementById('strokeText').checked;
            const isHorizontal = document.getElementById('horizontalText').checked;
            const currentStrokeColor = document.getElementById('strokeColor').value;
            const currentStrokeWidth = parseInt(document.getElementById('strokeWidth').value) || 3;

            const element = {
                type: 'text',
                content: document.getElementById('textContent').value || 'ãƒ†ã‚­ã‚¹ãƒˆ',
                x: canvas.width / 2 / displayScale,
                y: canvas.height / 2 / displayScale,
                fontSize: currentFontSize,
                fontFamily: currentFontFamily,
                color: currentColor,
                bold: isBold,
                stroke: isStroke,
                strokeColor: currentStrokeColor,
                strokeWidth: currentStrokeWidth,
                vertical: !isHorizontal // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æ¨ªæ›¸ããƒã‚§ãƒƒã‚¯ãŒãªã‘ã‚Œã°ç¸¦æ›¸ã
            };

            elements.push(element);
            selectedElement = element;
            selectedElements = [element];
            updateProperties();
            render();
        }

        // å¹ãå‡ºã—è¿½åŠ ï¼ˆé›²ã¯å‰Šé™¤ï¼‰
        function addBubble(shape) {
            if (!originalImage) {
                alert('å…ˆã«ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„');
                return;
            }

            // ç¾åœ¨ã®è¨­å®šå€¤ã‚’DOMã‹ã‚‰å–å¾—
            const currentColor = document.getElementById('bubbleColor').value;
            const currentBorderColor = document.getElementById('bubbleBorderColor').value;
            const currentOpacity = parseInt(document.getElementById('bubbleOpacity').value) / 100;

            const element = {
                type: 'bubble',
                shape: shape,
                x: canvas.width / 2 / displayScale,
                y: canvas.height / 2 / displayScale,
                width: 200,
                height: 150,
                color: currentColor,
                borderColor: currentBorderColor,
                opacity: currentOpacity
            };

            elements.push(element);
            selectedElement = element;
            selectedElements = [element];
            updateProperties();
            render();
        }

        // æç”»
        function render() {
            if (!originalImage) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç”»åƒã‚’50%ã‚¹ã‚±ãƒ¼ãƒ«ã§æç”»
            ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);

            // è¦ç´ ã‚’æç”»
            elements.forEach(element => {
                if (element.type === 'text') {
                    drawText(element);
                } else if (element.type === 'bubble') {
                    drawBubble(element);
                }

                // é¸æŠä¸­ã®è¦ç´ ã«ãƒãƒ³ãƒ‰ãƒ«ã‚’è¡¨ç¤º
                if (selectedElements.includes(element)) {
                    drawSelectionHandles(element);
                }
            });

            updateLayerList();
        }

        // ãƒ†ã‚­ã‚¹ãƒˆæç”»
        function drawText(element) {
            ctx.save();

            const x = element.x * displayScale;
            const y = element.y * displayScale;
            const fontSize = element.fontSize * displayScale;

            ctx.font = `${element.bold ? 'bold' : 'normal'} ${fontSize}px ${element.fontFamily}`;
            ctx.fillStyle = element.color;

            if (element.vertical) {
                // ç¸¦æ›¸ã
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center';

                const chars = element.content.split('');
                const lineHeight = fontSize * 1.2;
                const startY = y - (chars.length * lineHeight) / 2 + lineHeight / 2; // ä¸­å¿ƒè£œæ­£

                chars.forEach((char, index) => {
                    const charY = startY + index * lineHeight;

                    if (element.stroke) {
                        ctx.strokeStyle = element.strokeColor;
                        ctx.lineWidth = element.strokeWidth * displayScale;
                        ctx.strokeText(char, x, charY);
                    }

                    ctx.fillText(char, x, charY);
                });
            } else {
                // æ¨ªæ›¸ã
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center'; // ä¸­å¤®æƒãˆ

                if (element.stroke) {
                    ctx.strokeStyle = element.strokeColor;
                    ctx.lineWidth = element.strokeWidth * displayScale;
                    ctx.strokeText(element.content, x, y);
                }

                ctx.fillText(element.content, x, y);
            }

            ctx.restore();
        }

        // å¹ãå‡ºã—æç”»ï¼ˆé›²ãƒ­ã‚¸ãƒƒã‚¯å‰Šé™¤ï¼‰
        function drawBubble(element) {
            ctx.save();

            const x = element.x * displayScale;
            const y = element.y * displayScale;
            const width = element.width * displayScale;
            const height = element.height * displayScale;

            // é€éå‡¦ç†
            ctx.globalAlpha = element.opacity || 1.0;

            ctx.fillStyle = element.color;
            ctx.strokeStyle = element.borderColor;
            ctx.lineWidth = 2 * displayScale;

            ctx.beginPath();

            if (element.shape === 'rect') {
                ctx.rect(x - width / 2, y - height / 2, width, height);
                ctx.fill();
                ctx.stroke();
            } else if (element.shape === 'round') {
                // æ¥•å††
                ctx.ellipse(x, y, width / 2, height / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            } else if (element.shape === 'flash') {
                // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
                const spikes = 80;
                const outerRadiusX = width / 2;
                const outerRadiusY = height / 2;
                const innerRadiusX = width / 2 * 0.85;
                const innerRadiusY = height / 2 * 0.85;

                let rot = Math.PI / 2 * 3;
                let step = Math.PI / spikes;

                ctx.moveTo(x, y - outerRadiusY);
                for (let i = 0; i < spikes; i++) {
                    let cx = x + Math.cos(rot) * outerRadiusX;
                    let cy = y + Math.sin(rot) * outerRadiusY;
                    ctx.lineTo(cx, cy);
                    rot += step;

                    cx = x + Math.cos(rot) * innerRadiusX;
                    cy = y + Math.sin(rot) * innerRadiusY;
                    ctx.lineTo(cx, cy);
                    rot += step;
                }
                ctx.lineTo(x, y - outerRadiusY);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            } else if (element.shape === 'custom' && element.imageObj) {
                // ã‚«ã‚¹ã‚¿ãƒ ç”»åƒæç”»
                try {
                    ctx.drawImage(element.imageObj, x - width / 2, y - height / 2, width, height);
                } catch (e) {
                    console.error('Image draw error', e);
                }
            }

            ctx.restore();
        }

        // é¸æŠãƒãƒ³ãƒ‰ãƒ«æç”»
        function drawSelectionHandles(element) {
            ctx.save();

            let bounds = getElementBounds(element);
            const x = bounds.x * displayScale;
            const y = bounds.y * displayScale;
            const width = bounds.width * displayScale;
            const height = bounds.height * displayScale;

            // å¢ƒç•Œç·š
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(x, y, width, height);

            // ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«
            ctx.fillStyle = '#667eea';
            const handleSize = 8;

            ctx.fillRect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);
            ctx.fillRect(x + width - handleSize / 2, y - handleSize / 2, handleSize, handleSize);
            ctx.fillRect(x - handleSize / 2, y + height - handleSize / 2, handleSize, handleSize);
            ctx.fillRect(x + width - handleSize / 2, y + height - handleSize / 2, handleSize, handleSize);

            ctx.restore();
        }

        // è¦ç´ ã®å¢ƒç•Œå–å¾—
        function getElementBounds(element) {
            if (element.type === 'text') {
                ctx.font = `${element.bold ? 'bold' : 'normal'} ${element.fontSize}px ${element.fontFamily}`;

                if (element.vertical) {
                    const chars = element.content.split('');
                    const lineHeight = element.fontSize * 1.2;
                    const maxWidth = element.fontSize;
                    const totalHeight = chars.length * lineHeight;

                    // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°è¿½åŠ 
                    const padding = element.fontSize * 0.2;
                    return {
                        x: element.x - maxWidth / 2 - padding,
                        y: element.y - totalHeight / 2 - padding,
                        width: maxWidth + padding * 2,
                        height: totalHeight + padding * 2
                    };
                } else {
                    const metrics = ctx.measureText(element.content);
                    const width = metrics.width;
                    const height = element.fontSize;

                    // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°è¿½åŠ 
                    const padding = element.fontSize * 0.2;

                    return {
                        x: element.x - width / 2 - padding,
                        y: element.y - height / 2 - padding,
                        width: width + padding * 2,
                        height: height + padding * 2
                    };
                }
            } else if (element.type === 'bubble') {
                return {
                    x: element.x - element.width / 2,
                    y: element.y - element.height / 2,
                    width: element.width,
                    height: element.height
                };
            }
        }

        // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
        canvas.addEventListener('mousedown', function (e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / displayScale;
            const mouseY = (e.clientY - rect.top) / displayScale;

            if (selectedElement && selectedElements.length <= 1) {
                const handle = getResizeHandle(mouseX, mouseY, selectedElement);
                if (handle) {
                    isResizing = true;
                    resizeHandle = handle;
                    dragStartX = mouseX;
                    dragStartY = mouseY;
                    return;
                }
            }

            let clickedElement = null;
            for (let i = elements.length - 1; i >= 0; i--) {
                if (isPointInElement(mouseX, mouseY, elements[i])) {
                    clickedElement = elements[i];
                    break;
                }
            }

            if (clickedElement) {
                isDragging = true;
                dragStartX = mouseX;
                dragStartY = mouseY;

                if (e.ctrlKey || e.metaKey) {
                    const index = selectedElements.indexOf(clickedElement);
                    if (index >= 0) {
                        selectedElements.splice(index, 1);
                        if (clickedElement === selectedElement) {
                            selectedElement = selectedElements.length > 0 ? selectedElements[selectedElements.length - 1] : null;
                        }
                    } else {
                        selectedElements.push(clickedElement);
                        selectedElement = clickedElement;
                    }
                } else {
                    if (!selectedElements.includes(clickedElement)) {
                        selectedElements = [clickedElement];
                        selectedElement = clickedElement;
                    } else {
                        selectedElement = clickedElement;
                    }
                }
            } else {
                if (!e.ctrlKey && !e.metaKey) {
                    selectedElements = [];
                    selectedElement = null;
                }
            }

            updateProperties();
            render();
        });

        canvas.addEventListener('mousemove', function (e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / displayScale;
            const mouseY = (e.clientY - rect.top) / displayScale;

            // ã‚«ãƒ¼ã‚½ãƒ«è¡¨ç¤º
            if (!isDragging && !isResizing && selectedElement && selectedElements.length <= 1) {
                const handle = getResizeHandle(mouseX, mouseY, selectedElement);
                if (handle === 'se' || handle === 'nw') {
                    canvas.style.cursor = 'nwse-resize';
                } else if (handle === 'sw' || handle === 'ne') {
                    canvas.style.cursor = 'nesw-resize';
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            } else if (!isDragging && !isResizing) {
                canvas.style.cursor = 'crosshair';
            }

            if (isResizing && selectedElement) {
                const dx = mouseX - dragStartX;
                const dy = mouseY - dragStartY;

                if (selectedElement.type === 'bubble') {
                    if (resizeHandle === 'se') {
                        selectedElement.width = Math.max(50, selectedElement.width + dx);
                        selectedElement.height = Math.max(50, selectedElement.height + dy);
                        selectedElement.x += dx / 2;
                        selectedElement.y += dy / 2;
                    } else if (resizeHandle === 'sw') {
                        selectedElement.width = Math.max(50, selectedElement.width - dx);
                        selectedElement.height = Math.max(50, selectedElement.height + dy);
                        selectedElement.x += dx / 2;
                        selectedElement.y += dy / 2;
                    } else if (resizeHandle === 'ne') {
                        selectedElement.width = Math.max(50, selectedElement.width + dx);
                        selectedElement.height = Math.max(50, selectedElement.height - dy);
                        selectedElement.x += dx / 2;
                        selectedElement.y += dy / 2;
                    } else if (resizeHandle === 'nw') {
                        selectedElement.width = Math.max(50, selectedElement.width - dx);
                        selectedElement.height = Math.max(50, selectedElement.height - dy);
                        selectedElement.x += dx / 2;
                        selectedElement.y += dy / 2;
                    }
                } else if (selectedElement.type === 'text') {
                    // ãƒãƒ³ãƒ‰ãƒ«ä½ç½®ã«å¿œã˜ã¦ãƒ‰ãƒ©ãƒƒã‚°é‡ã®ç¬¦å·ã‚’èª¿æ•´
                    let delta = 0;
                    if (resizeHandle === 'se') {
                        delta = dx + dy;
                    } else if (resizeHandle === 'sw') {
                        delta = -dx + dy;
                    } else if (resizeHandle === 'ne') {
                        delta = dx - dy;
                    } else if (resizeHandle === 'nw') {
                        delta = -dx - dy;
                    }

                    const scaleFactor = 1 + delta / 100;

                    // å°æ•°ç‚¹ä»¥ä¸‹ã‚‚ä¿æŒã™ã‚‹ã‚ˆã†ã«Math.roundã‚’å‰Šé™¤
                    const newFontSize = Math.max(10, Math.min(200, selectedElement.fontSize * scaleFactor));
                    selectedElement.fontSize = newFontSize;
                    document.getElementById('fontSize').value = Math.round(selectedElement.fontSize); // è¡¨ç¤ºã¯è¦‹ã‚„ã™ãæ•´æ•°ã§
                }

                dragStartX = mouseX;
                dragStartY = mouseY;
                render();
            } else if (isDragging && selectedElements.length > 0) {
                const dx = mouseX - dragStartX;
                const dy = mouseY - dragStartY;

                selectedElements.forEach(el => {
                    el.x += dx;
                    el.y += dy;
                });

                dragStartX = mouseX;
                dragStartY = mouseY;
                render();
            }
        });

        canvas.addEventListener('mouseup', function () {
            isDragging = false;
            isResizing = false;
            resizeHandle = null;
        });

        function getResizeHandle(x, y, element) {
            const bounds = getElementBounds(element);
            const handleSize = 10;

            if (Math.abs(x - (bounds.x + bounds.width)) < handleSize &&
                Math.abs(y - (bounds.y + bounds.height)) < handleSize) {
                return 'se';
            }
            if (Math.abs(x - bounds.x) < handleSize &&
                Math.abs(y - (bounds.y + bounds.height)) < handleSize) {
                return 'sw';
            }
            if (Math.abs(x - (bounds.x + bounds.width)) < handleSize &&
                Math.abs(y - bounds.y) < handleSize) {
                return 'ne';
            }
            if (Math.abs(x - bounds.x) < handleSize &&
                Math.abs(y - bounds.y) < handleSize) {
                return 'nw';
            }

            return null;
        }

        function isPointInElement(x, y, element) {
            const bounds = getElementBounds(element);
            return x >= bounds.x && x <= bounds.x + bounds.width &&
                y >= bounds.y && y <= bounds.y + bounds.height;
        }

        // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£æ›´æ–°
        function updateProperties() {
            if (!selectedElement) return;

            if (selectedElement.type === 'text') {
                document.getElementById('textContent').value = selectedElement.content;
                document.getElementById('fontSize').value = selectedElement.fontSize;
                document.getElementById('fontFamily').value = selectedElement.fontFamily;
                document.getElementById('textColor').value = selectedElement.color;
                document.getElementById('boldText').checked = selectedElement.bold;
                document.getElementById('strokeText').checked = selectedElement.stroke;
                document.getElementById('strokeColor').value = selectedElement.strokeColor;
                document.getElementById('strokeWidth').value = selectedElement.strokeWidth;

                document.getElementById('horizontalText').checked = !selectedElement.vertical; // ç¸¦æ›¸ãã®é€†

                // ç¸å–ã‚Šã‚ªãƒ—ã‚·ãƒ§ãƒ³è¡¨ç¤ºæ›´æ–°
                document.getElementById('strokeOptions').style.display = selectedElement.stroke ? 'flex' : 'none';
            } else if (selectedElement.type === 'bubble') {
                document.getElementById('bubbleColor').value = selectedElement.color;
                document.getElementById('bubbleBorderColor').value = selectedElement.borderColor;
                const opacity = Math.round((selectedElement.opacity || 1.0) * 100);
                document.getElementById('bubbleOpacity').value = opacity;
                document.getElementById('opacityValue').textContent = opacity;
            }
        }

        // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆ
        document.getElementById('textContent').addEventListener('input', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.content = this.value;
                render();
            }
        });

        document.getElementById('fontSize').addEventListener('input', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.fontSize = parseInt(this.value);
                render();
            }
        });

        document.getElementById('fontFamily').addEventListener('change', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.fontFamily = this.value;
                render();
            }
        });

        document.getElementById('textColor').addEventListener('input', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.color = this.value;
                render();
            }
        });

        document.getElementById('boldText').addEventListener('change', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.bold = this.checked;
                render();
            }
        });

        document.getElementById('strokeText').addEventListener('change', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.stroke = this.checked;
                render();
            }
        });

        document.getElementById('horizontalText').addEventListener('change', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.vertical = !this.checked; // ãƒã‚§ãƒƒã‚¯æ™‚ã¯æ¨ªæ›¸ã(vertical=false)
                render();
            }
        });

        document.getElementById('strokeColor').addEventListener('input', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.strokeColor = this.value;
                render();
            }
        });

        document.getElementById('strokeWidth').addEventListener('input', function () {
            if (selectedElement && selectedElement.type === 'text') {
                selectedElement.strokeWidth = parseInt(this.value);
                render();
            }
        });

        document.getElementById('bubbleColor').addEventListener('input', function () {
            if (selectedElement && selectedElement.type === 'bubble') {
                selectedElement.color = this.value;
                render();
            }
        });

        document.getElementById('bubbleBorderColor').addEventListener('input', function () {
            if (selectedElement && selectedElement.type === 'bubble') {
                selectedElement.borderColor = this.value;
                render();
            }
        });

        document.getElementById('bubbleOpacity').addEventListener('input', function () {
            if (selectedElement && selectedElement.type === 'bubble') {
                const opacity = parseInt(this.value) / 100;
                selectedElement.opacity = opacity;
                document.getElementById('opacityValue').textContent = this.value;
                render();
            }
        });

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†
        function updateLayerList() {
            const layerList = document.getElementById('layerList');
            layerList.innerHTML = '';

            elements.slice().reverse().forEach((element, index) => {
                const actualIndex = elements.length - 1 - index;
                const div = document.createElement('div');
                div.className = 'layer-item' + (selectedElements.includes(element) ? ' selected' : '');
                div.onclick = function (e) {
                    if (e.ctrlKey || e.metaKey) {
                        const idx = selectedElements.indexOf(element);
                        if (idx >= 0) {
                            selectedElements.splice(idx, 1);
                            if (element === selectedElement) {
                                selectedElement = selectedElements.length > 0 ? selectedElements[selectedElements.length - 1] : null;
                            }
                        } else {
                            selectedElements.push(element);
                            selectedElement = element;
                        }
                    } else {
                        selectedElement = element;
                        selectedElements = [element];
                    }
                    updateProperties();
                    render();
                };

                const name = element.type === 'text' ?
                    `ğŸ“ ${element.content.substring(0, 10)}` :
                    `ğŸ’­ ${element.shape}å¹ãå‡ºã—`;

                div.innerHTML = `
                    <span>${name}</span>
                    <span style="font-size: 0.8em; color: #999;">Layer ${actualIndex + 1}</span>
                `;

                layerList.appendChild(div);
            });
        }

        function moveToFront() {
            if (!selectedElement) return;
            const index = elements.indexOf(selectedElement);
            if (index !== -1 && index < elements.length - 1) {
                elements.splice(index, 1);
                elements.push(selectedElement);
                render();
            }
        }

        function moveToBack() {
            if (!selectedElement) return;
            const index = elements.indexOf(selectedElement);
            if (index > 0) {
                elements.splice(index, 1);
                elements.unshift(selectedElement);
                render();
            }
        }

        function deleteSelected() {
            if (selectedElements.length === 0) return;

            elements = elements.filter(el => !selectedElements.includes(el));

            selectedElements = [];
            selectedElement = null;
            updateProperties();
            render();
        }

        // ä¿å­˜ãƒ»èª­è¾¼
        function saveProject() {
            if (!originalImage) {
                alert('ä¿å­˜ã™ã‚‹ç”»åƒãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }

            const data = {
                imageData: originalImage.src,
                elements: elements
            };

            const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'project.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function (e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (event) {
                        const data = JSON.parse(event.target.result);

                        const img = new Image();
                        img.onload = function () {
                            originalImage = img;
                            canvas.width = img.width * displayScale;
                            canvas.height = img.height * displayScale;
                            elements = data.elements;
                            selectedElement = null;
                            selectedElements = [];
                            render();
                        };
                        img.src = data.imageData;
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function exportImage() {
            if (!originalImage) {
                alert('å‡ºåŠ›ã™ã‚‹ç”»åƒãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }

            // å…ƒã®è§£åƒåº¦ã§ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆ
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = originalImage.width;
            exportCanvas.height = originalImage.height;
            const exportCtx = exportCanvas.getContext('2d');

            // ç”»åƒã‚’æç”»
            exportCtx.drawImage(originalImage, 0, 0);

            // è¦ç´ ã‚’å…ƒã®ã‚¹ã‚±ãƒ¼ãƒ«ã§æç”»
            const originalScale = displayScale;
            displayScale = 1.0;

            elements.forEach(element => {
                if (element.type === 'text') {
                    exportCtx.save();
                    exportCtx.font = `${element.bold ? 'bold' : 'normal'} ${element.fontSize}px ${element.fontFamily}`;
                    exportCtx.fillStyle = element.color;

                    if (element.vertical) {
                        // ç¸¦æ›¸ã
                        exportCtx.textBaseline = 'middle';
                        exportCtx.textAlign = 'center';

                        const chars = element.content.split('');
                        const lineHeight = element.fontSize * 1.2;
                        const startY = element.y - (chars.length * lineHeight) / 2 + lineHeight / 2; // ä¸­å¿ƒè£œæ­£

                        chars.forEach((char, index) => {
                            const charY = startY + index * lineHeight;

                            if (element.stroke) {
                                exportCtx.strokeStyle = element.strokeColor;
                                exportCtx.lineWidth = element.strokeWidth;
                                exportCtx.strokeText(char, element.x, charY);
                            }

                            exportCtx.fillText(char, element.x, charY);
                        });
                    } else {
                        // æ¨ªæ›¸ã
                        exportCtx.textBaseline = 'middle';
                        exportCtx.textAlign = 'center'; // ä¸­å¤®æƒãˆ

                        if (element.stroke) {
                            exportCtx.strokeStyle = element.strokeColor;
                            exportCtx.lineWidth = element.strokeWidth;
                            exportCtx.strokeText(element.content, element.x, element.y);
                        }

                        exportCtx.fillText(element.content, element.x, element.y);
                    }
                    exportCtx.restore();
                } else if (element.type === 'bubble') {
                    exportCtx.save();
                    exportCtx.globalAlpha = element.opacity || 1.0;
                    exportCtx.fillStyle = element.color;
                    exportCtx.strokeStyle = element.borderColor;
                    exportCtx.lineWidth = 2;

                    exportCtx.beginPath();

                    const x = element.x;
                    const y = element.y;
                    const width = element.width;
                    const height = element.height;

                    if (element.shape === 'rect') {
                        exportCtx.rect(x - width / 2, y - height / 2, width, height);
                        exportCtx.fill();
                        exportCtx.stroke();
                    } else if (element.shape === 'round') {
                        exportCtx.ellipse(x, y, width / 2, height / 2, 0, 0, Math.PI * 2);
                        exportCtx.fill();
                        exportCtx.stroke();
                    } else if (element.shape === 'flash') {
                        const spikes = 80;
                        const outerRadiusX = width / 2;
                        const outerRadiusY = height / 2;
                        const innerRadiusX = width / 2 * 0.85;
                        const innerRadiusY = height / 2 * 0.85;

                        let rot = Math.PI / 2 * 3;
                        let step = Math.PI / spikes;

                        exportCtx.moveTo(x, y - outerRadiusY);
                        for (let i = 0; i < spikes; i++) {
                            let cx = x + Math.cos(rot) * outerRadiusX;
                            let cy = y + Math.sin(rot) * outerRadiusY;
                            exportCtx.lineTo(cx, cy);
                            rot += step;

                            cx = x + Math.cos(rot) * innerRadiusX;
                            cy = y + Math.sin(rot) * innerRadiusY;
                            exportCtx.lineTo(cx, cy);
                            rot += step;
                        }
                        exportCtx.lineTo(x, y - outerRadiusY);
                        exportCtx.closePath();
                        exportCtx.fill();
                        exportCtx.stroke();
                    } else if (element.shape === 'custom' && element.imageObj) {
                        try {
                            exportCtx.drawImage(element.imageObj, x - width / 2, y - height / 2, width, height);
                        } catch (e) {
                            console.error('Export draw error', e);
                        }
                    }
                    exportCtx.restore();
                }
            });

            displayScale = originalScale;

            exportCanvas.toBlob(function (blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'output.png';
                a.click();
                URL.revokeObjectURL(url);
            }, 'image/png', 0.8); // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºå‰Šæ¸›ã®ãŸã‚å“è³ªèª¿æ•´
        }

        // ==========================================
        // ã‚«ã‚¹ã‚¿ãƒ ã‚¢ã‚»ãƒƒãƒˆç®¡ç†æ©Ÿèƒ½ (IndexedDB)
        // ==========================================

        const DB_NAME = 'ImageEditorAssets';
        const DB_VERSION = 1;
        let db = null;

        // DBåˆæœŸåŒ–
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = function (e) {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('fonts')) {
                        db.createObjectStore('fonts', { keyPath: 'id', autoIncrement: true });
                    }
                    if (!db.objectStoreNames.contains('bubbles')) {
                        db.createObjectStore('bubbles', { keyPath: 'id', autoIncrement: true });
                    }
                };

                request.onsuccess = function (e) {
                    db = e.target.result;
                    resolve(db);
                };

                request.onerror = function (e) {
                    console.error('DB Error', e);
                    reject(e);
                };
            });
        }

        // ãƒ‡ãƒ¼ã‚¿ã®è¿½åŠ 
        function addToDB(storeName, data) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.add(data);

                request.onsuccess = function (e) {
                    resolve(e.target.result);
                };

                request.onerror = function (e) {
                    reject(e);
                };
            });
        }

        // å…¨ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
        function getAllFromDB(storeName) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();

                request.onsuccess = function (e) {
                    resolve(e.target.result);
                };

                request.onerror = function (e) {
                    reject(e);
                };
            });
        }

        // ãƒ‡ãƒ¼ã‚¿ã®å‰Šé™¤
        function deleteFromDB(storeName, id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(id);

                request.onsuccess = function () {
                    resolve();
                };

                request.onerror = function (e) {
                    reject(e);
                };
            });
        }

        // åˆæœŸåŒ–å‡¦ç†
        initDB().then(() => {
            loadCustomFonts();
            loadCustomBubbles();
        });

        // ------------------------------------------
        // ãƒ•ã‚©ãƒ³ãƒˆç®¡ç†
        // ------------------------------------------

        document.getElementById('fontInput').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (evt) {
                const fontData = evt.target.result; // ArrayBuffer
                const fontName = file.name.replace(/\.[^/.]+$/, ""); // æ‹¡å¼µå­é™¤å»

                // ãƒ•ã‚©ãƒ³ãƒˆãƒ­ãƒ¼ãƒ‰
                loadFontToDocument(fontName, fontData).then(() => {
                    // DBä¿å­˜
                    addToDB('fonts', {
                        name: fontName,
                        content: fontData, // ãã®ã¾ã¾ä¿å­˜ã§ããªã„å ´åˆãŒã‚ã‚‹ãŒã€Blobæ¨å¥¨ã€‚ã“ã“ã§ã¯ArrayBuffer
                        fileName: file.name
                    }).then(() => {
                        loadCustomFonts(); // ãƒªã‚¹ãƒˆæ›´æ–°
                        alert(`ãƒ•ã‚©ãƒ³ãƒˆ "${fontName}" ã‚’è¿½åŠ ã—ã¾ã—ãŸ`);
                    });
                }).catch(err => {
                    alert('ãƒ•ã‚©ãƒ³ãƒˆã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    console.error(err);
                });
            };
            reader.readAsArrayBuffer(file);
            this.value = '';
        });

        async function loadCustomFonts() {
            const fonts = await getAllFromDB('fonts');
            const list = document.getElementById('customFontList');
            const select = document.getElementById('fontFamily');

            list.innerHTML = '';

            // æ—¢å­˜ã®ã‚«ã‚¹ã‚¿ãƒ ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ã‚¯ãƒªã‚¢ï¼ˆæ¨™æº–ä»¥å¤–ï¼‰
            let optGroup = select.querySelector('optgroup[label="ã‚«ã‚¹ã‚¿ãƒ "]');
            if (!optGroup) {
                optGroup = document.createElement('optgroup');
                optGroup.label = "ã‚«ã‚¹ã‚¿ãƒ ";
                select.appendChild(optGroup);
            }
            optGroup.innerHTML = ''; // ã‚¯ãƒªã‚¢

            for (const font of fonts) {
                // UIãƒªã‚¹ãƒˆã«è¿½åŠ  (éè¡¨ç¤º)
                /* 
                const div = document.createElement('div');
                div.innerHTML = `
                    <span>${font.name}</span>
                    <span class="font-delete-btn" onclick="removeFont(${font.id})">âœ–</span>
                `;
                list.appendChild(div);
                */

                // ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã«è¿½åŠ 
                const option = document.createElement('option');
                option.value = font.name;
                option.textContent = font.name;
                optGroup.appendChild(option);

                // ã¾ã ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ãƒ­ãƒ¼ãƒ‰
                if (!document.fonts.check(`12px "${font.name}"`)) {
                    loadFontToDocument(font.name, font.content);
                }
            }
        }

        function loadFontToDocument(name, data) {
            const fontFace = new FontFace(name, data);
            return fontFace.load().then(loadedFace => {
                document.fonts.add(loadedFace);
                return loadedFace;
            });
        }

        window.removeFont = function (id) {
            if (confirm('ã“ã®ãƒ•ã‚©ãƒ³ãƒˆã‚’å‰Šé™¤ã—ã¦ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) {
                deleteFromDB('fonts', id).then(() => {
                    loadCustomFonts();
                });
            }
        };

        // ------------------------------------------
        // å¹ãå‡ºã—ç®¡ç†
        // ------------------------------------------

        document.getElementById('bubbleInput').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (evt) {
                const dataUrl = evt.target.result;

                addToDB('bubbles', {
                    content: dataUrl,
                    name: file.name
                }).then(() => {
                    loadCustomBubbles();
                });
            };
            reader.readAsDataURL(file);
            this.value = '';
        });

        async function loadCustomBubbles() {
            const bubbles = await getAllFromDB('bubbles');
            const list = document.getElementById('customBubbleList');
            list.innerHTML = '';

            for (const bubble of bubbles) {
                const div = document.createElement('div');
                div.className = 'custom-item';
                div.style.backgroundImage = `url(${bubble.content})`;

                // å‰Šé™¤ãƒœã‚¿ãƒ³
                const delBtn = document.createElement('div');
                delBtn.className = 'delete-btn';
                delBtn.textContent = 'âœ•';
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    removeBubble(bubble.id);
                };
                div.appendChild(delBtn);

                // ã‚¯ãƒªãƒƒã‚¯ã§è¿½åŠ 
                div.onclick = () => {
                    addCustomBubble(bubble.content);
                };

                // ãƒ›ãƒãƒ¼ã§ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
                div.addEventListener('mousemove', (e) => {
                    const popup = document.getElementById('previewPopup');
                    const img = document.getElementById('previewImage');
                    popup.style.display = 'flex';
                    popup.style.left = (e.clientX + 15) + 'px';
                    popup.style.top = (e.clientY + 15) + 'px';
                    if (img.src !== bubble.content) {
                        img.src = bubble.content;
                    }
                });

                div.addEventListener('mouseleave', () => {
                    document.getElementById('previewPopup').style.display = 'none';
                });

                list.appendChild(div);
            }
        }

        window.removeBubble = function (id) {
            if (confirm('ã“ã®å¹ãå‡ºã—ç”»åƒã‚’å‰Šé™¤ã—ã¦ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) {
                deleteFromDB('bubbles', id).then(() => {
                    loadCustomBubbles();
                });
            }
        };

        function addCustomBubble(dataUrl) {
            if (!originalImage) {
                alert('å…ˆã«ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„');
                return;
            }

            const img = new Image();
            img.onload = function () {
                const element = {
                    type: 'bubble',
                    shape: 'custom',
                    // ç”»åƒã®èª­ã¿è¾¼ã¿ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦åˆæœŸã‚µã‚¤ã‚ºæ±ºå®šï¼ˆå¤§ãã™ããªã„ã‚ˆã†ã«åˆ¶é™ï¼‰
                    width: Math.min(200, img.width),
                    height: Math.min(150, img.width * (img.height / img.width)),
                    x: canvas.width / 2 / displayScale,
                    y: canvas.height / 2 / displayScale,
                    color: '#ffffff', // ã‚«ã‚¹ã‚¿ãƒ ç”»åƒã«ã¯åŠ¹ã‹ãªã„ãŒãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ä¿æŒ
                    borderColor: '#000000',
                    opacity: 1.0,
                    source: dataUrl, // ä¿å­˜ç”¨DataURL
                    imageObj: img // æç”»ç”¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
                };

                // ã‚µã‚¤ã‚ºãŒå°ã•ã™ãã‚‹å ´åˆã®è£œæ­£
                if (element.width < 50) element.width = 50;
                if (element.height < 50) element.height = 50;

                if (element.width < 50) element.width = 50;
                if (element.height < 50) element.height = 50;

                elements.push(element);
                selectedElement = element;
                selectedElements = [element];
                updateProperties();
                render();
            };
            img.src = dataUrl;
        }

        // ä¿å­˜ãƒ»èª­è¾¼ã®ä¿®æ­£ï¼ˆã‚«ã‚¹ã‚¿ãƒ å¹ãå‡ºã—å¯¾å¿œï¼‰
        const originalLoadProject = window.loadProject;

        window.loadProject = function () {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function (e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (event) {
                        const data = JSON.parse(event.target.result);

                        const img = new Image();
                        img.onload = function () {
                            originalImage = img;
                            canvas.width = img.width * displayScale;
                            canvas.height = img.height * displayScale;

                            // è¦ç´ ã®å¾©å…ƒ
                            elements = [];
                            const loadPromises = data.elements.map(el => {
                                return new Promise((resolve) => {
                                    if (el.type === 'bubble' && el.shape === 'custom' && el.source) {
                                        const customImg = new Image();
                                        customImg.onload = function () {
                                            el.imageObj = customImg;
                                            resolve(el);
                                        };
                                        customImg.onerror = function () {
                                            el.shape = 'rect';
                                            resolve(el);
                                        }
                                        customImg.src = el.source;
                                    } else {
                                        resolve(el);
                                    }
                                });
                            });

                            Promise.all(loadPromises).then(loadedElements => {
                                elements = loadedElements;
                                selectedElement = null;
                                selectedElements = [];
                                render();
                            });
                        };
                        img.src = data.imageData;
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        };

    </script>
</body>

</html>